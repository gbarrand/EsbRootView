// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file EsbRootView.license for terms.

#ifndef EsbRootView_EsbRootView_vis_plots
#define EsbRootView_EsbRootView_vis_plots

#include "dac"
#include "evaluators"

#include <exlib/xml/xml_style>
#include <inlib/xml/wrap_viewplot_style> // inlib/xml/viewplot.style file embeded in an inline function.

#include <inlib/sg/view_plots>
#include <inlib/sg/plotarea>
#include <inlib/sg/args2style>

namespace EsbRootView {

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// hist : ///////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline inlib::histo::h1d* hist_MCTracks(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::hist_MCTracks : bad dac cast.");return 0;}

  const std::vector<EsbMCTrack*>& tracks = _dac->event().mc_tracks();

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::sg::get_style(a_gv.styles(),"MCTrack",a_args,_style);

  if(_style.filling.value().empty()) {
    a_gv.insh().warn("EsbRootView::hist_MCTracks : no filling script given.");
    return 0;
  }

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  EsbMCTrack_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::hist_MCTracks : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return 0;
  }

  std::vector<EsbMCTrack*> cut_tracks;
  if(_style.cut.value().empty()) {
    cut_tracks = tracks;
  } else {
    bool ok;
    inlib_vforcit(EsbMCTrack*,tracks,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_tracks.clear();break;}
      if(ok) cut_tracks.push_back(*it);
    }
  }

  EsbMCTrack_evaluator _eval_filling(a_gv.out(),_style.filling.value(),_dac->event());
  if(!_eval_filling.is_valid()) {
    a_gv.insh().warn("EsbRootView::hist_MCTracks : bad script "+inlib::sout(_style.filling.value())+" for filling evaluator.");
    return 0;
  }
  double _min_filling,_max_filling;
  if(!_eval_filling.evaluate_double_min_max(cut_tracks,_min_filling,_max_filling)) {
    a_gv.insh().warn("EsbRootView::hist_MCTracks : min_max() failed.");
    return 0;
  }
  if(_max_filling<=_min_filling) {
    a_gv.insh().warn("EsbRootView::hist_MCTracks : max <= min.");
    return 0;
  }
  
  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  std::string title = "MCTrack ";
  if(_style.cut.value().size()) title += _style.cut.value()+" ";
  title += _style.filling.value();

  inlib::histo::h1d* h = new inlib::histo::h1d(title,100,_min_filling,_max_filling);

  double dvalue;
  inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
    if(!_eval_filling.evaluate_double(*(*it),dvalue)) {}
    h->fill(dvalue);
  }

  return h;
}

inline inlib::histo::h1d* hist_DetectorPoints(dac& a_dac,const std::string& a_data,
                            const inlib::sg::style& a_style,const std::vector<EsbDetectorPoint*>& a_points) {
  //const std::vector<EsbMCTrack*>& tracks = a_dac.event().mc_tracks();

  if(a_style.filling.value().empty()) {
    a_dac.gv().insh().warn("EsbRootView::hist_DetectorPoints : no filling script given.");
    return 0;
  }

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbDetectorPoint_evaluator _eval_cut(a_dac.gv().out(),a_style.cut.value(),a_dac.event());
  if(!_eval_cut.is_valid()) {
    a_dac.gv().insh().warn("EsbRootView::hist_DetectorPoints : bad script "+inlib::sout(a_style.cut.value())+" for cut evaluator.");
    return 0;
  }

  std::vector<EsbDetectorPoint*> cut_points;
  if(a_style.cut.value().empty()) {
    cut_points = a_points;
  } else {
    bool ok;
    inlib_vforcit(EsbDetectorPoint*,a_points,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_points.clear();break;}
      if(ok) cut_points.push_back(*it);
    }
  }

  EsbDetectorPoint_evaluator _eval_filling(a_dac.gv().out(),a_style.filling.value(),a_dac.event());
  if(!_eval_filling.is_valid()) {
    a_dac.gv().insh().warn("EsbRootView::hist_DetectorPoints : bad script "+inlib::sout(a_style.filling.value())+" for filling evaluator.");
    return 0;
  }
  double _min_filling,_max_filling;
  if(!_eval_filling.evaluate_double_min_max(cut_points,_min_filling,_max_filling)) {
    a_dac.gv().insh().warn("EsbRootView::hist_DetectorPoints : min_max() failed.");
    return 0;
  }
  if(_max_filling<=_min_filling) {
    a_dac.gv().insh().warn("EsbRootView::hist_DetectorPoints : max <= min.");
    return 0;
  }
  
  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  std::string title = a_data+" ";
  if(a_style.cut.value().size()) title += a_style.cut.value()+" ";
  title += a_style.filling.value();

  inlib::histo::h1d* h = new inlib::histo::h1d(title,100,_min_filling,_max_filling);

  double dvalue;
  inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
    if(!_eval_filling.evaluate_double(*(*it),dvalue)) {}
    h->fill(dvalue);
  }

  return h;
}

inline inlib::histo::h1d* hist_Fgd(dac& a_dac,const std::string& a_data,const std::vector<std::string>& a_args)		     {
  const std::vector<EsbFgdHit*>& hits = a_dac.event().fgd_hits();

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::sg::get_style(a_dac.gv().styles(),a_data,a_args,_style);
  
  if(_style.filling.value().empty()) {
    a_dac.gv().insh().warn("EsbRootView::hist_Fgd : no filling script given.");
    return 0;
  }

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  EsbFgdHit_evaluator _eval_cut(a_dac.gv().out(),_style.cut.value(),a_dac.event());
  if(!_eval_cut.is_valid()) {
    a_dac.gv().insh().warn("EsbRootView::hist_Fgd : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return 0;
  }
  
  std::vector<EsbFgdHit*> cut_hits;
  if(_style.cut.value().empty()) {
    cut_hits = hits;
  } else {
    bool ok;
    inlib_vforcit(EsbFgdHit*,hits,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_hits.clear();break;}
      if(ok) cut_hits.push_back(*it);
    }
  }
  
  EsbFgdHit_evaluator _eval_filling(a_dac.gv().out(),_style.filling.value(),a_dac.event());
  if(!_eval_filling.is_valid()) {
    a_dac.gv().insh().warn("EsbRootView::hist_Fgd : bad script "+inlib::sout(_style.filling.value())+" for filling evaluator.");
    return 0;
  }
  double _min_filling,_max_filling;
  if(!_eval_filling.evaluate_double_min_max(cut_hits,_min_filling,_max_filling)) {
    a_dac.gv().insh().warn("EsbRootView::hist_Fgd : min_max() failed.");
    return 0;
  }
  if(_max_filling<=_min_filling) {
    a_dac.gv().insh().warn("EsbRootView::hist_Fgd : max <= min.");
    return 0;
  }
  
  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  std::string title = a_data+" ";
  if(_style.cut.value().size()) title += _style.cut.value()+" ";
  title += _style.filling.value();

  inlib::histo::h1d* h = new inlib::histo::h1d(title,100,_min_filling,_max_filling);

  double dvalue;
  inlib_vforcit(EsbFgdHit*,cut_hits,it) {
    if(!_eval_filling.evaluate_double(*(*it),dvalue)) {}
    h->fill(dvalue);
  }

  return h;
}

inline inlib::histo::h2d* hist2D_DetectorPoints(dac& a_dac,bool a_near,double a_radius,double a_length,const std::vector<EsbDetectorPoint*>& a_points) {
  std::ostream& out = a_dac.gv().out();

  //////////////////////////////////////////////////////////
  /// create and fill histo : //////////////////////////////
  //////////////////////////////////////////////////////////
  // from EsbRoot/display_event_ND.C.
 
  std::string title;
  inlib::sprintf(title,80,"Event #%lu",a_dac.event().event_index());
    
  inlib::histo::h2d* hEvent =
    new inlib::histo::h2d(title,
                          100, -a_radius-50, a_radius + a_length + 2*a_radius + 50,
                          100, -a_radius*inlib::pi()-50, a_radius*inlib::pi()+300);

  size_t nPhotons = a_points.size();

  for(size_t n = 0; n < nPhotons; n++) {
    EsbDetectorPoint* photon = a_points[n];

    double xP,yP,zP,rP;
    if(a_near) {
      xP = photon->GetX();
      yP = photon->GetY();
      zP = photon->GetZ();
      rP = ::sqrt(xP*xP + yP*yP);
    } else {
      xP =  photon->GetX();
      yP = -photon->GetZ();
      zP =  photon->GetY();
      rP = ::sqrt(xP*xP + yP*yP);
    }
    
    // Find the location of the photon hit
    int location = -1;
    if(::fabs(zP - a_length/2.0) < 1) { // front
      location = 1;
    }
    else if(::fabs(zP + a_length/2) < 1) { // back
      location = 3;
    }
    else if (::fabs(rP - a_radius) < 1) { // side
      
      location = 2;
    } else {
    
      out << "hist2D_DetectorPoint : hit was not on detector edge :" << std::endl;
      out << "  front epsil " << ::fabs(zP - a_length/2.0) << std::endl;
      out << "  back epsil "  << ::fabs(zP + a_length/2.0) << std::endl;
      out << "  side epsil "  << ::fabs(rP - a_radius) << std::endl;
      
      a_dac.gv().insh().warn("EsbRootView::hist2D_DetectorPoints : hit is not on detector edge.");
      delete hEvent;
      return 0;
    }

    // Now we need to find out where to fill the hit
    double x=0, y=0;

    if(location == 3) { // back. Ellipse at left.
      
      x = -xP;
      y =  yP;
    } else if (location == 1) { // front. Ellipse at right.
      
      x = xP + a_length + 2*a_radius;
      y = yP; 
    } else if (location == 2) { // frontside
      
      x = zP + a_radius + a_length/2.0; 
      y = ::atan2(yP, -xP) * a_radius; 
    }
    
    hEvent->Fill(x, y);
  }

  return hEvent;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// plotting : ///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool load_embeded_styles(inlib::xml::styles& a_styles) {
  std::string ss;
  unsigned int linen;
  const char** lines = viewplot_style(linen);
  for(unsigned int index=0;index<linen;index++) {
    std::string s = lines[index];
    inlib::replace(s,"@@double_quote@@","\"");
    inlib::replace(s,"@@back_slash@@","\\");
    ss += s + "\n";
  }
  return exlib::xml::load_style_string(a_styles,ss);
}

inline void setup_plotter(std::ostream& a_out,inlib::sg::plotter& a_plotter,double a_radius,double a_length) {
  //////////////////////////////////////////////////////////
  /// style : //////////////////////////////////////////////
  //////////////////////////////////////////////////////////
  inlib::sg::plotter& sgp = a_plotter;
  
  sgp.background_style().visible = true;

  inlib::xml::styles styles(a_out);
  styles.add_colormap("default",inlib::sg::style_default_colormap());
  styles.add_colormap("ROOT",inlib::sg::style_ROOT_colormap());
  load_embeded_styles(styles);
  sgp.reset_style();
  inlib::sg::style_from_res(styles,"ROOT_default",sgp,true);

  sgp.title_box_style().visible = false;
  sgp.infos_style().visible = false;
  
  sgp.title_to_axis = 0.03f;
  sgp.title_style().visible = true;
  sgp.title_style().scale = 3;
  sgp.title_style().font = inlib::sg::font_arialbd_ttf();
  sgp.title_style().font_modeling = inlib::sg::font_pixmap;

  //hEvent->Draw("COLZ");
  sgp.bins_style(0).color = inlib::colorf_red();
  sgp.bins_style(0).modeling = inlib::sg::modeling_solid();
  sgp.bins_style(0).painting = inlib::sg::painting_violet_to_red;
  
  //TEllipse* ellipse = new TEllipse();
  //ellipse->SetLineWidth(2);
  //ellipse->SetFillStyle(0);
  //ellipse->DrawEllipse(0, 0, a_radius, 0, 0, 360, 0);
  //ellipse->DrawEllipse(a_radius+a_length+a_radius, 0, a_radius, 0, 0, 360, 0);

  sgp.add_primitive
    (new inlib::sg::plottable_ellipse(0,0,float(a_radius),float(a_radius),
                                      inlib::sg::plottable_ellipse::HOLLOW,inlib::colorf_white(),0,0,inlib::colorf_black(),2));
  sgp.add_primitive
    (new inlib::sg::plottable_ellipse(float(a_radius+a_length+a_radius),0,float(a_radius),float(a_radius),
                                      inlib::sg::plottable_ellipse::HOLLOW,inlib::colorf_white(),0,0,inlib::colorf_black(),2));
		
  //TBox* box = new TBox();
  //box->SetLineWidth(2);
  //box->SetFillStyle(0);
  //box->DrawBox(a_radius, -a_radius*TMath::Pi(), a_radius+a_length, a_radius*TMath::Pi());

  sgp.add_primitive
    (new inlib::sg::plottable_box(float(a_radius),float(-a_radius*inlib::pi()),float(a_radius+a_length),float(a_radius*inlib::pi()),
                                  inlib::sg::plottable_box::HOLLOW,inlib::colorf_white(),0,0,inlib::colorf_black(),2));
  
  //TLatex* latex = new TLatex();
  //latex->SetTextSize(0.06);
  //latex->SetTextAlign(22);
  //latex->DrawLatex(0                         , a_radius*TMath::Pi()+200, "BACK");
  //latex->DrawLatex(a_radius+a_length/2       , a_radius*TMath::Pi()+200, "SIDE");
  //latex->DrawLatex(a_radius+a_length+a_radius, a_radius*TMath::Pi()+200, "FRONT");

  // latex->SetTextAlign(h*10+v);
  // horizontal :
  //  2    TA_CENTER
  //  3    TA_RIGHT
  //  else TA_LEFT
  // vertical :
  //  1    TA_BASELINE
  //  2    TA_TOP
  //  3    TA_TOP
  //  else TA_BASELINE
  // 22 in ROOT is for horizontal/center and vertical/top.

//float y_min = -a_radius*inlib::pi()-50;       //from the h2d booking.
  float y_max =  a_radius*inlib::pi()+300;      //from the h2d booking.
  float top_box = float(a_radius*inlib::pi());  //from the upper box size.
  
  float text_y = (y_max+top_box)*0.5f;
  
  float text_height = (2*float(a_radius*inlib::pi()))*0.09f;

  sgp.add_primitive
    (new inlib::sg::plottable_text("BACK",0,text_y,
                                 //0.06f,false,
                                   text_height,inlib::sg::plottable_text::text_enforce_height,
                                   0,'C','M',
                                   inlib::sg::font_arialbd_ttf(),inlib::colorf_black(),1,true,true,1,inlib::sg::font_pixmap));
  sgp.add_primitive
    (new inlib::sg::plottable_text("SIDE",float(a_radius+a_length/2),text_y,
                                 //0.06f,false,
                                   text_height,inlib::sg::plottable_text::text_enforce_height,
                                   0,'C','M',
                                   inlib::sg::font_arialbd_ttf(),inlib::colorf_black(),1,true,true,1,inlib::sg::font_pixmap));
  sgp.add_primitive
    (new inlib::sg::plottable_text("FRONT",float(a_radius+a_length+a_radius),text_y,
                                 //0.06f,false,
                                   text_height,inlib::sg::plottable_text::text_enforce_height,
                                   0,'C','M',
                                   inlib::sg::font_arialbd_ttf(),inlib::colorf_black(),1,true,true,1,inlib::sg::font_pixmap));

  sgp.set_axes_font_modeling(inlib::sg::font_pixmap);
  
}

inline void setup_plotter(std::ostream& a_out,inlib::sg::plotter& a_plotter) {
  //////////////////////////////////////////////////////////
  /// style : //////////////////////////////////////////////
  //////////////////////////////////////////////////////////
  inlib::sg::plotter& sgp = a_plotter;
  
  sgp.background_style().visible = true;

  inlib::xml::styles styles(a_out);
  styles.add_colormap("default",inlib::sg::style_default_colormap());
  styles.add_colormap("ROOT",inlib::sg::style_ROOT_colormap());
  load_embeded_styles(styles);
  sgp.reset_style();
  inlib::sg::style_from_res(styles,"ROOT_default",sgp,true);
  sgp.set_axes_font_modeling(inlib::sg::font_pixmap);
}

inline inlib::sg::plots* find_sg_plots(inlib::sg::gui_viewer& a_gv) {
  inlib::sg::plots* plots = inlib::sg::search_plots(a_gv);
  if(!plots) return 0;
  inlib::sg::plotarea* _plotarea = inlib::sg::cast_plotarea(a_gv);
  if(_plotarea && (_plotarea->get_plots()==plots)) {
    inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
    if(_evd) {_evd->dynamic_sg().add(_plotarea->create_plots_clearer_holder());}
  }
  return plots;
}

inline bool MCTrack_plot(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
//inlib::sg::plots* plots = inlib::sg::get_plots(a_gv);  //if not done, it creates a sg::plots in static_sg().
  inlib::sg::plots* plots = find_sg_plots(a_gv);
  if(!plots) return false;
  inlib::sg::plotter& sgp = plots->current_plotter();
  sgp.clear();
  inlib::histo::h1d* h = hist_MCTracks(a_gv,a_args);
  if(!h) return false;
  setup_plotter(a_gv.out(),sgp);
  sgp.add_plottable(new inlib::sg::h1d2plot_cp(*h));
  delete h;
  return true;
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
INLIB_GLOBAL_STRING_VALUE(modeling_neard,neard)
INLIB_GLOBAL_STRING_VALUE(modeling_fard,fard)

inline void plot_DetectorPoints(dac& a_dac,const std::string& a_data,const std::vector<std::string>& a_args,
                                const std::vector<EsbDetectorPoint*>& a_points) {
//inlib::sg::plots* plots = inlib::sg::get_plots(a_dac.gv());  //if not done, it creates a sg::plots in static_sg().
  inlib::sg::plots* plots = find_sg_plots(a_dac.gv());
  if(!plots) return;
  inlib::sg::style _style;
  _style.modeling.value().clear();
  inlib::sg::get_style(a_dac.gv().styles(),a_data,a_args,_style);
  inlib::sg::plotter& sgp = plots->current_plotter();
  sgp.clear();
  if(_style.modeling==s_modeling_neard()) {
    inlib::histo::h2d* h = hist2D_DetectorPoints(a_dac,true,300,1000,a_points);
    if(!h) return;
    setup_plotter(a_dac.gv().out(),sgp,300,1000);
    sgp.add_plottable(new inlib::sg::h2d2plot_cp(*h));
    delete h;
  } else if(_style.modeling==s_modeling_fard()) {
    inlib::histo::h2d* h = hist2D_DetectorPoints(a_dac,false,3540,2*2740,a_points);
    if(!h) return;
    setup_plotter(a_dac.gv().out(),sgp,3540,2*2740);
    sgp.add_plottable(new inlib::sg::h2d2plot_cp(*h));
    delete h;
  } else if(_style.modeling.value().empty()) {
    inlib::histo::h1d* h = hist_DetectorPoints(a_dac,a_data,_style,a_points);
    if(!h) return;
    setup_plotter(a_dac.gv().out(),sgp);
    sgp.add_plottable(new inlib::sg::h1d2plot_cp(*h));
    delete h;
  } else {
    a_dac.gv().insh().warn("EsbRootView::plot_DetectorPoints : unknown modeling style "+_style.modeling.value()+".");
  }
}

inline void WCDetectorPoint_plot(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;
  plot_DetectorPoints(*_dac,"WCDetectorPoint",a_args,_dac->event().wc_points());
}
inline void FgdDetectorPoint_plot(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;
  plot_DetectorPoints(*_dac,"FgdDetectorPoint",a_args,_dac->event().fgd_points());
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

inline bool plot_Fgd(dac& a_dac,const std::string& a_data,const std::vector<std::string>& a_args) {
//inlib::sg::plots* plots = inlib::sg::get_plots(a_dac.gv());  //if not done, it creates a sg::plots in static_sg().
  inlib::sg::plots* plots = find_sg_plots(a_dac.gv());
  if(!plots) return false;
  inlib::sg::plotter& sgp = plots->current_plotter();
  sgp.clear();
  inlib::histo::h1d* h = hist_Fgd(a_dac,a_data,a_args);
  if(!h) return false;
  setup_plotter(a_dac.gv().out(),sgp);
  sgp.add_plottable(new inlib::sg::h1d2plot_cp(*h));
  delete h;
  return true;
}

inline bool FgdHit_plot(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return false;
  return plot_Fgd(*_dac,"FgdHit",a_args);
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
inline bool plain_plot_setup(inlib::sg::gui_viewer& a_gv) {
  inlib::sg::plotarea::action_hide_plots(a_gv);
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) return false;
  _evd->static_sg().clear();
  _evd->dynamic_sg().clear();
  if(!inlib::sg::get_sg_plots(a_gv)) {  //if not done, it creates a sg::plots in static_sg() by using view_plots/create_evd_sg_plots().
    a_gv.insh().warn("EsbRootView::plain_plot_setup : sg::plots not found.");
    return false;
  }    
  return true;
}

}

#endif
