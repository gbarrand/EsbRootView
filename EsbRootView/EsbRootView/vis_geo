// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file EsbRootView.license for terms.

#ifndef EsbRootView_EsbRootView_vis_geo
#define EsbRootView_EsbRootView_vis_geo

#include <inlib/sg/view_evd>

#include <inlib/rroot/file>
#include <inlib/rroot/geo>
#include <inlib/rroot/geo_manager>

#include <exlib/zlib>

namespace EsbRootView {

inline inlib::sg::return_action action_vis_geo(inlib::sg::gui_viewer& a_gv) {
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) return inlib::sg::return_none;

  if(!_evd->is_evd()) {
    float scene_radius = 1500;
    _evd->create_sg_evd(scene_radius);
  }

  std::string path = a_gv.res_dir()+inlib::sep()+"geo_full.root";

  inlib::rroot::geo_manager* mgr = a_gv.find_in_tmp_group<inlib::rroot::geo_manager>(path);
  if(!mgr) {
    bool verbose = false;
    inlib::rroot::file* rfile = new inlib::rroot::file(a_gv.out(),path,verbose);
    rfile->add_unziper('Z',exlib::decompress_buffer);
  
    inlib::rroot::key* key = rfile->dir().find_key_from_class("TGeoManager");
    if(!key) {
      delete rfile;
      a_gv.map_warn("TGeoManager key not found.");
      return inlib::sg::return_none;
    }
  
    unsigned int sz;
    char* buf = key->get_object_buffer(*rfile,sz);
    if(!buf) {
      delete rfile;
      a_gv.map_warn("can't get data buffer TGeoManager key.");
      return inlib::sg::return_none;
    }
      
    inlib::rroot::buffer b(a_gv.out(),rfile->byte_swap(),sz,buf,key->key_length(),verbose);
    b.set_map_objs(true);
  
  //a_gv.out() << "debug : stream in geom..." << std::endl;        
    
    mgr = new inlib::rroot::geo_manager(a_gv.out());
    if(!mgr->stream(b)) {
      delete mgr;
      delete rfile;
      a_gv.map_warn("streaming failed for TGeoManager.");
      return inlib::sg::return_none;
    }
    delete rfile; //not needed anymore.
          
    const inlib::rroot::geo_volume* master = mgr->master();
    if(!master) {
      delete mgr;
      a_gv.map_warn("no master volume.");
      return inlib::sg::return_none;
    }
  
    a_gv.remove_in_tmp_group<inlib::rroot::geo_manager>(path);
    a_gv.add_in_tmp_group<inlib::rroot::geo_manager>(path,mgr);
  }

  const inlib::rroot::geo_volume* master = mgr->master();
      
  inlib::rroot::geo* geo = new inlib::rroot::geo(*master);

  geo->volume = "wc";
  geo->volume_depth = 1;

  geo->min_depth = 0;
  geo->max_depth = 2;
  geo->solid_depth = 10;

  geo->atb = inlib::sg::atb_single;
  geo->color = inlib::colorf_cyan();

  //geo->atb = sg::atb_by_depth;
  //geo->set_cmap(cmap);
  
  //geo->max_time = max_time;
  //geo->max_shapes = max_shapes;

  //force an update now :
  //a_gv.out() << "debug : create_scenario_sg : update_sg..." << std::endl;
  geo->update_sg(a_gv.out());
  geo->reset_touched(); //avoid another update_sg at first render().
  
  //if(geo->stopped_by_max_time())   some_stopped_by_max_time = true;
  //if(geo->stopped_by_max_shapes()) some_stopped_by_max_shapes = true;

  if(geo->volume_not_found()) {
    //some_not_found = true;
    a_gv.out() << "volume " << geo->volume.value() << " not found." << std::endl;
    delete geo;
  } else {
    inlib::sg::separator& dsep = _evd->static_sg();
    inlib::sg::separator* sep = new inlib::sg::separator;
    sep->add(new inlib::sg::matrix()); //for manip.
    sep->add(geo);
    dsep.add(sep);
  }
  
  a_gv.hide_main_menu();
  
  return inlib::sg::return_to_render;
}

}

#endif
