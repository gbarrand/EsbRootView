// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file EsbRootView.license for terms.

#ifndef EsbRootView_sg_dac
#define EsbRootView_sg_dac

//dac = data accessor

#include "read_event"

#include <exlib/zlib>

#include <inlib/sg/gui_viewer>

#include <inlib/rroot/geo_manager>
#include <inlib/rroot/tree_manip>
#include <inlib/rroot/fac>

#include <inlib/hep/load_pdg_table>
#include <inlib/hep/pdg>

namespace EsbRootView {

class dac {
public:
  INLIB_SCLASS(EsbRootView::dac)
public:
  dac(inlib::sg::gui_viewer& a_gv)
  :m_gv(a_gv)
  ,m_geo_manager(0)
  ,m_geo_file()
  ,m_factory(a_gv.out())
  ,m_event_file(0)
  ,m_tree(0)
  ,m_pdgs(a_gv.out())
  ,m_one_event()
  {
    if(!inlib::hep::load_default_pdg_table(a_gv.tmp_dir(),m_pdgs)) {}
  }
  virtual ~dac(){
    delete m_tree;
    delete m_event_file;
    delete m_geo_manager;
  }
protected:
  dac(const dac& a_from)
  :m_gv(a_from.m_gv)
  ,m_geo_manager(0)
  ,m_geo_file(a_from.m_geo_file)
  ,m_factory(a_from.m_factory)
  ,m_event_file(0)
  ,m_tree(0)
  ,m_pdgs(a_from.m_pdgs)
  {}
  dac& operator=(const dac& a_from){
    m_geo_file = a_from.m_geo_file;
    m_factory = a_from.m_factory;
    m_pdgs = a_from.m_pdgs;
    return *this;
  }
public:
  bool is_geometry_file(const std::string& a_path)  {
    inlib::rroot::file* rfile = new inlib::rroot::file(m_gv.out(),a_path,false);
    if(!rfile) return false;
    inlib::rroot::key* key = rfile->dir().find_key_from_class("TGeoManager");
    delete rfile;
    return key?true:false;
  }
  
  bool open_geometry_file(const std::string& a_path)  {
    delete m_geo_manager;
    m_geo_manager = 0;
    m_geo_file.clear();
    m_geo_infos.clear();
    
    bool verbose = false;
    inlib::rroot::file* rfile = new inlib::rroot::file(m_gv.out(),a_path,verbose);
    if(!rfile) {
      m_gv.map_warn("can't open");
      m_gv.show_console("no geometry");
      return false;
    }
    rfile->add_unziper('Z',exlib::decompress_buffer);
  
    inlib::rroot::key* key = rfile->dir().find_key_from_class("TGeoManager");
    if(!key) {
      delete rfile;
      m_gv.map_warn("TGeoManager key not found.");
      return false;
    }
  
    unsigned int sz;
    char* buf = key->get_object_buffer(*rfile,sz);
    if(!buf) {
      delete rfile;
      m_gv.map_warn("can't get data buffer TGeoManager key.");
      return false;
    }
      
    inlib::rroot::buffer b(m_gv.out(),rfile->byte_swap(),sz,buf,key->key_length(),verbose);
  
  //m_gv.out() << "debug : stream in geom..." << std::endl;        
    
    inlib::rroot::geo_manager* mgr = new inlib::rroot::geo_manager(m_gv.out());
    if(!mgr || !mgr->stream(b)) {
      delete mgr;
      delete rfile;
      m_gv.map_warn("streaming failed for TGeoManager.");
      return false;
    }
    
    delete rfile; //not needed anymore.
    
    const inlib::rroot::geo_volume* master = mgr->master();
    if(!master) {
      delete mgr;
      m_gv.map_warn("no master volume.");
      return false;
    }

    m_geo_manager = mgr;
    m_geo_file = a_path;
    
    get_geo_infos();
    
   {std::string stmp;
    if(!inlib::size_t2s(mgr->volumes().size(),stmp)){}
    m_gv.show_console(stmp+" volumes");}
    
    return true;
  }
  
  const inlib::rroot::geo_volume* master_volume() const {
    if(!m_geo_manager) return 0;
    return m_geo_manager->master();
  }
  
  bool is_event_file(const std::string& a_path) {
    bool verbose = false;
    inlib::rroot::file* rfile = new inlib::rroot::file(m_gv.out(),a_path,verbose);
    if(!rfile) return false;
    rfile->add_unziper('Z',exlib::decompress_buffer);
    inlib::rroot::key* key = rfile->dir().find_key(s_tree_cbmsim());
    if(!key) {delete rfile;return false;}
    // cross check that we have a TTree:
    bool map_objs = true;
    inlib::rroot::tree* tree = inlib::rroot::find_tree(*rfile,m_factory,s_tree_cbmsim(),map_objs);      
    bool tree_found = tree?true:false;
    delete tree;
    delete rfile;
    return tree_found;
  }

  bool open_event_file(const std::string& a_path) {
    reset_event_file();
    m_event_infos.clear();
    m_one_event.clear();
    
    bool verbose = false;
    inlib::rroot::file* rfile = new inlib::rroot::file(m_gv.out(),a_path,verbose);
    if(!rfile) {
      m_gv.map_warn("can't open");
      m_gv.show_console("no events");
      return false;
    }
    rfile->add_unziper('Z',exlib::decompress_buffer);
  //inlib::rroot::dump(out,*rfile,rfile->dir().keys(),true);
    m_event_file = rfile;

    bool map_objs = true;
    m_tree = inlib::rroot::find_tree(*m_event_file,m_factory,s_tree_cbmsim(),map_objs);      
    if(!m_tree) {
      m_gv.map_warn("tree "+s_tree_cbmsim()+" not found");
      m_gv.show_console("no events");
      reset_event_file();
      return false;
    }

   {std::string stmp;
    if(!inlib::num2s((inlib::uint64)m_tree->entries(),stmp)){}
    m_gv.show_console(stmp+" events");}

    return true;
  }

  bool read_one_event(unsigned int a_index) {
    if(!m_tree) {
      m_gv.map_warn("no tree");
      return false;
    }
    read_event(*m_tree,a_index,m_one_event,m_pdgs,m_gv.verbose());
    m_one_event.set_event_index(a_index);
    get_event_infos();
    return true;	
  }
  
  inlib::uint64 number_of_events() const {
    if(!m_tree) return 0;
    return m_tree->entries();
  }
  
  inlib::sg::gui_viewer& gv() {return m_gv;}
  const one_event& event() const {return m_one_event;}
  const std::vector<std::string>& event_infos() const {return m_event_infos;}
  const std::vector<std::string>& geo_infos() const {return m_geo_infos;}
protected:
  void reset_event_file() {
    delete m_tree;
    delete m_event_file;
    m_tree = 0;
    m_event_file = 0;  
  }
  INLIB_CLASS_STRING_VALUE(tree_cbmsim,cbmsim)

  void get_event_infos() {
    m_event_infos.clear();

    size_t primary_MCTracks = 0;
    size_t cherenkov_MCTracks = 0;
    double track_time_min = DBL_MAX;
    double track_time_max = 0;
   {inlib_vforcit(EsbMCTrack*,m_one_event.mc_tracks(),it) {
      if((*it)->GetMotherId()==no_mother()) primary_MCTracks++;
      if((*it)->GetPdgCode()==inlib::pdg::cherenkov()) cherenkov_MCTracks++;
      track_time_min = inlib::mn<double>(track_time_min,(*it)->GetStartT());
      track_time_max = inlib::mx<double>(track_time_max,(*it)->GetStartT());
    }}
      
    //::printf("debug : infos : num tracks %lu, wc_points %lu, fgd_points %lu\n",tracks.size(),wc_points.size(),fgd_points.size());
    //::printf("debug : infos : track time min %g, max %g\n",track_time_min,track_time_max);
    
    double wc_time_min = DBL_MAX;
    double wc_time_max = 0;
   {inlib_vforcit(EsbDetectorPoint*,m_one_event.wc_points(),it) {
      wc_time_min = inlib::mn<double>(wc_time_min,(*it)->GetTime());
      wc_time_max = inlib::mx<double>(wc_time_max,(*it)->GetTime());
    }}
    
    std::string sevents;
    inlib::num2s(number_of_events(),sevents);
    
    std::string sevent_index;
    inlib::num2s(m_one_event.event_index(),sevent_index);
    
    std::string snumber_MCTracks;
    inlib::size_t2s(m_one_event.mc_tracks().size(),snumber_MCTracks);
  
    std::string snumber_WCDetectorPoints;
    inlib::size_t2s(m_one_event.wc_points().size(),snumber_WCDetectorPoints);
    
    std::string snumber_FgdDetectorPoints;
    inlib::size_t2s(m_one_event.fgd_points().size(),snumber_FgdDetectorPoints);
    
    std::string snumber_cherenkov_MCTracks;
    inlib::size_t2s(cherenkov_MCTracks,snumber_cherenkov_MCTracks);
  
    std::string snumber_not_cherenkov_MCTracks;
    inlib::size_t2s(m_one_event.mc_tracks().size()-cherenkov_MCTracks,snumber_not_cherenkov_MCTracks);
  
    std::string snumber_primary_MCTracks;
    inlib::size_t2s(primary_MCTracks,snumber_primary_MCTracks);
  
    std::string strack_time_min;
    inlib::num2s(track_time_min,strack_time_min);
    std::string strack_time_max;
    inlib::num2s(track_time_max,strack_time_max);
    std::string swc_time_min;
    inlib::num2s(wc_time_min,swc_time_min);
    std::string swc_time_max;
    inlib::num2s(wc_time_max,swc_time_max);
  
    std::string snumber_FgdHits;
    inlib::size_t2s(m_one_event.fgd_hits().size(),snumber_FgdHits);

    std::string event_file_name;
    if(m_event_file) inlib::base_name(m_event_file->path(),event_file_name);

    m_event_infos.push_back("file : "+event_file_name);
    m_event_infos.push_back("events : "+sevents);
    m_event_infos.push_back("event : "+sevent_index);
    m_event_infos.push_back("MCTracks : "+snumber_MCTracks);
    m_event_infos.push_back("MCTracks_cherenkov : "+snumber_cherenkov_MCTracks);
    m_event_infos.push_back("MCTracks_not_cherenkov : "+snumber_not_cherenkov_MCTracks);
    m_event_infos.push_back("MCTracks_primary : "+snumber_primary_MCTracks);
    m_event_infos.push_back("MCTracks time min : "+strack_time_min);
    m_event_infos.push_back("MCTracks time max : "+strack_time_max);
    m_event_infos.push_back("WCDetectorPoints : "+snumber_WCDetectorPoints);
    m_event_infos.push_back("WCPoints time min : "+swc_time_min);
    m_event_infos.push_back("WCPoints time max : "+swc_time_max);
    m_event_infos.push_back("FgdDetectorPoints : "+snumber_FgdDetectorPoints);
    m_event_infos.push_back("FgdHits : "+snumber_FgdHits);
  }  
  void get_geo_infos() {
    m_geo_infos.clear();

    std::string geo_file_name;
    inlib::base_name(m_geo_file,geo_file_name);
    m_geo_infos.push_back("geo file : "+geo_file_name);
    
    if(m_geo_manager) {
      //const inlib::rroot::geo_volume* master = m_geo_manager->master();
      //if(!master) {a_gv.insh().warn("vis_geometry","no master volume.");return false;}
      std::string svoln;
      inlib::size_t2s(m_geo_manager->volumes().size(),svoln);
      m_geo_infos.push_back("voln : "+svoln);
    }      
  }  
protected:
  inlib::sg::gui_viewer& m_gv;
  inlib::rroot::geo_manager* m_geo_manager;
  std::string m_geo_file;
  inlib::rroot::fac m_factory;
  inlib::rroot::file* m_event_file;
  inlib::rroot::tree* m_tree;
  inlib::hep::pdgs m_pdgs;
  one_event m_one_event;
  std::vector<std::string> m_event_infos;
  std::vector<std::string> m_geo_infos;
};

inline dac* cast_dac(inlib::sg::viewer& a_viewer) {
  return inlib::safe_cast<inlib::sg::viewer,dac>(a_viewer);
}

}

#endif
