// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file EsbRootView.license for terms.

#ifndef EsbRootView_EsbRootView_vis
#define EsbRootView_EsbRootView_vis

#include "dac"
#include "evaluators"
#include "strings"
#include "firework"

#include <exlib/sg/text_freetype_marker>

#include <inlib/sg/view_evd>
#include <inlib/sg/view_sg_client>
#include <inlib/sg/hep_arrow>
#include <inlib/sg/args2style>
#include <inlib/sg/cone_anim>
#include <inlib/sg/hep_cone_anim>
#include <inlib/sg/xyzt_anim>

#include <inlib/yacc/get_colormap>

#include <inlib/rroot/geo>
#include <inlib/randf>

namespace EsbRootView {

inline int no_mother() {return -1;}

class dumper : public inlib::sg::base_dumper {
  typedef inlib::sg::base_dumper parent;
public:
  virtual void get_infos(const std::string& /*a_tag*/,std::vector<std::string>& a_v) const {a_v = m_infos;}
  virtual base_dumper* copy() const {return new dumper(*this);}
public:
  dumper(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_infos)
  :parent(a_gv)
  ,m_infos(a_infos)
  {}
  virtual ~dumper(){}
public:
  dumper(const dumper& a_from)
  :parent(a_from)
  ,m_infos(a_from.m_infos)
  {}
  dumper& operator=(const dumper& a_from){
    parent::operator=(a_from);
    m_infos = a_from.m_infos;
    return *this;
  }
public:
  std::vector<std::string> m_infos;
};

template <class EVAL,class DATA>
inline inlib::sg::infos* create_sg_infos(inlib::sg::gui_viewer& a_gv,EVAL& a_eval,const DATA& a_data) {
  inlib::sg::infos* infos = new inlib::sg::infos;
  std::string sobj;
  inlib::p2s(infos,sobj);
  infos->strings.add(sobj);
  infos->strings.add("no_tag");
  std::vector<std::string> vinfos;
  a_eval.get_infos(a_data,vinfos);
  a_gv.add_dumper(sobj,new dumper(a_gv,vinfos));
  return infos;
}

template <class EVAL,class DATA,class VTXS>
inline inlib::sg::separator* create_sg_pickable(inlib::sg::gui_viewer& a_gv,EVAL& a_eval,const DATA& a_data,VTXS*& a_vtxs) {
  inlib::sg::separator* sep = new inlib::sg::separator;
  sep->add(new inlib::sg::matrix);  //for move_manip.
  sep->add(create_sg_infos(a_gv,a_eval,a_data));
  a_vtxs = new VTXS;
  a_vtxs->mode = inlib::gl::points();
  sep->add(a_vtxs);
  return sep;
}

inline bool place_sep(inlib::sg::view_evd& a_evd,inlib::sg::separator*& a_sep) {
  a_evd.dynamic_sg().add(a_sep);
  inlib::args opts;
  opts.add(inlib::sg::s_send_placement(),inlib::sg::s_placement_dynamic());
  inlib::sg::view_sg_client* wc = inlib::sg::cast_view_sg_client(a_evd.gv());
  if(wc && wc->is_connected()) {if(!wc->send_sg(*a_sep,opts)){}}
  return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// MCTrack : ////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void MCTrack_cut(const dac& a_dac,const inlib::sg::style& a_style,
                        EsbMCTrack_evaluator& a_eval_cut,
                        std::vector<EsbMCTrack*>& a_cut_tracks) {
  a_cut_tracks.clear();

  if(a_style.cut.value().empty()) {
    a_cut_tracks = a_dac.event().mc_tracks();
  } else {
    bool ok;
    inlib_vforcit(EsbMCTrack*,a_dac.event().mc_tracks(),it) {
      if(!a_eval_cut.accept(*(*it),ok)) {a_cut_tracks.clear();break;}
      if(ok) a_cut_tracks.push_back(*it);
    }
  }
}

inline void MCTrack_count(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::MCTrack_count : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"MCTrack",_args,_style);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  EsbMCTrack_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::MCTrack_count : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbMCTrack*> cut_tracks;
  MCTrack_cut(*_dac,_style,_eval_cut,cut_tracks);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  if(a_gv.insh().in_backquote()) {
    a_gv.insh().out_size_t(cut_tracks.size());
  } else {
    a_gv.out () << "MCTrack with cut " << inlib::sout(_style.cut.value()) << " = " << cut_tracks.size() << std::endl;
  }
}

inline void MCTrack_print(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::MCTrack_print : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"MCTrack",_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  EsbMCTrack_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::MCTrack_print : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbMCTrack*> cut_tracks;
  MCTrack_cut(*_dac,_style,_eval_cut,cut_tracks);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  std::string sheader = "MCTrack (";
  inlib::size_tas(cut_tracks.size(),sheader);
  sheader += ") with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";

 {std::vector<std::string> vout;
  if(a_gv.insh().in_backquote()) {
    _eval_cut.dump(a_gv.out(),cut_tracks,names,sheader,true,vout);
    a_gv.insh().out_begin();
    a_gv.insh().out(vout,true);
  } else {
    _eval_cut.dump(a_gv.out(),cut_tracks,names,sheader,false,vout);
  }}
}

inline void MCTrack_stats(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::MCTrack_stats : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"MCTrack",_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  std::string stats_arg;
  if(_args.is_arg("-sum"))  stats_arg = "sum";
  if(_args.is_arg("-min"))  stats_arg = "min";
  if(_args.is_arg("-max"))  stats_arg = "max";
  if(_args.is_arg("-mean")) stats_arg = "mean";
  if(_args.is_arg("-rms"))  stats_arg = "rms";

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////
  EsbMCTrack_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::MCTrack_stats : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbMCTrack*> cut_tracks;
  MCTrack_cut(*_dac,_style,_eval_cut,cut_tracks);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  std::string sheader = "MCTrack (";
  inlib::size_tas(cut_tracks.size(),sheader);
  sheader += ") sum/min/max/mean/rms with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";

  std::string sout;
  _eval_cut.stats(a_gv.out(),cut_tracks,names,sheader,stats_arg,sout);
  if(sout.size()) a_gv.insh().out(sout);
}

inline void MCTrack_vis(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) {a_gv.insh().warn("EsbRootView::MCTrack_vis : bad evd cast.");return;}
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::MCTrack_vis : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  _style.modeling.value().clear();
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"MCTrack",_args,_style);

  bool anim = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(MCTrack_vis,anim,)

  static const double c_light_vacuum = 29.9792458;  //cm/nsec. Yes, it is const! :-)
//static const double c_light_water = 22.5;  //cm/nsec.
  static const float absorption_length_water = 1000.0f;

  float speed = c_light_vacuum;
  INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,speed,)
  if(speed<0) speed = c_light_vacuum;

//std::string splacement_object;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_object)
//std::string splacement_class;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_class)

  //////////////////////////////////////
  ///////////////////////1///////////////
  //////////////////////////////////////
  EsbMCTrack_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::MCTrack_vis : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbMCTrack*> cut_tracks;
  MCTrack_cut(*_dac,_style,_eval_cut,cut_tracks);

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  inlib::sg::base_colormap* _cmap = 0;
  double _min_coloring,_max_coloring,_range_coloring;
  EsbMCTrack_evaluator _eval_coloring(a_gv.out(),_style.coloring.value(),_dac->event());
  if(_style.coloring.value().size()) {
    if(!_eval_coloring.is_valid()) {
      a_gv.insh().warn("EsbRootView::MCTrack_vis : bad script "+inlib::sout(_style.coloring.value())+" for coloring evaluator.");
      return;
    }
    _cmap = inlib::get_colormap(a_gv.out(),_style,a_gv.styles().cmaps(),cut_tracks,_eval_coloring,_min_coloring,_max_coloring);
    _range_coloring = _max_coloring-_min_coloring;
  }

  EsbMCTrack_evaluator* _eval_arrow_length = 0;

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  inlib::sg::separator* sep = new inlib::sg::separator;
  bool empty = true;

  //////////////////////////////////////
  /// rep arraw : //////////////////////
  //////////////////////////////////////
  if(_style.modeling.value()==inlib::sg::modeling_arrow()) {

    sep->add(new inlib::sg::matrix);  //for move_manip.

    /////////////////////////////////////
    /////////////////////////////////////
    /////////////////////////////////////
    std::string sarrow_length;
    float arrow_radius = 0.05f;
    float arrow_text_scale = 4;
    float arrow_text_pos = 0.3f;
    bool arrow_base_tube = false;

   {const inlib::xml::styles::style_t* sty = a_gv.styles().find_style("MCTrack_arrow");
    if(sty) {
      inlib_vforcit(inlib::xml::styles::style_item_t,*sty,vit) {
             if((*vit).first=="length")     {sarrow_length = (*vit).second;}
        else if((*vit).first=="radius")     {if(!inlib::to<float>((*vit).second,arrow_radius,0.05f)) {}}
        else if((*vit).first=="text_scale") {if(!inlib::to<float>((*vit).second,arrow_text_scale,4.0f)) {}}
        else if((*vit).first=="text_pos")   {if(!inlib::to<float>((*vit).second,arrow_text_pos,0.3f)) {}}
        else if((*vit).first=="base_tube")  {if(!inlib::tob((*vit).second,arrow_base_tube,false)) {}}
      }
    }}

    INLIB_GUI_VIEWER_GET_ARG_STRING(arrow_length)

    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,arrow_radius,)
    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,arrow_text_scale,)
    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,arrow_text_pos,)
    INLIB_GUI_VIEWER_GET_ARG_BOOL(MCTrack_vis,arrow_base_tube,)

    float arrow_length = 10;
    if(inlib::rm_eval_parenthesis(sarrow_length)) {
      _eval_arrow_length = new EsbMCTrack_evaluator(a_gv.out(),sarrow_length,_dac->event());
    } else {
      if(!inlib::to<float>(sarrow_length,arrow_length,10.0f)) {}
    }

    /////////////////////////////////////
    /////////////////////////////////////
    /////////////////////////////////////


    exlib::sg::text_freetype_marker* ttf_marker = new exlib::sg::text_freetype_marker;
    sep->add(new inlib::sg::holder<exlib::sg::text_freetype_marker>(ttf_marker));

    inlib::colorf _color;

    inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
      EsbMCTrack* track = *it;
    //int pdg = track->GetPdgCode();
    //int mother_id = track->GetMotherId();

      //std::string mother_info("no mother");
      //if((mother_id>=0)&&(mother_id<int(_dac->event().mc_tracks().size()))) {
      //  const EsbMCTrack* mother_track = _dac->event().mc_tracks()[mother_id];
      //  int mother_pdg = mother_track->GetPdgCode();
      //  std::string smother_pdg;
      //  inlib::num2s(mother_pdg,smother_pdg);
      //  mother_info = mother_track->name()+" ("+smother_pdg+")";
      //}

      if(_eval_arrow_length) {
        double darrow_length;
        if(!_eval_arrow_length->evaluate_double(*track,darrow_length)) {}
        arrow_length = float(darrow_length);
      }

      inlib::vec3f vtx(float(track->GetStartX()),float(track->GetStartY()),float(track->GetStartZ()));
      inlib::vec3f dir(float(track->GetPx()),float(track->GetPy()),float(track->GetPz()));
      dir.normalize();

      //std::string name;
      //if(pdef) name = pdef->name();
      //else     inlib::num2s(pdg,name);
      const std::string& name = (*it)->name();

      inlib::vec3f beg(vtx);
      //if(mother_id==no_mother()) beg = vtx-arrow_length*dir;

      if(_cmap) {
        double value;
        if(!_eval_coloring.evaluate_double(*track,value)) {}
        _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
      } else {
        _color = _style.color.value();
      }

      inlib::sg::infos* infos = create_sg_infos(a_gv,_eval_cut,*(*it)); //picking infos.

      //::printf("debug : pdg %d : %g %g %g\n",pdg,beg.x(),beg.y(),beg.z());
      inlib::sg::separator* _sep_arrow =
        inlib::sg::create_arrow(beg,dir,arrow_length,arrow_radius,arrow_base_tube,name,
                                arrow_text_scale,arrow_text_pos,*ttf_marker,_color,infos);
      sep->add(_sep_arrow);
      empty = false;
    }

  //////////////////////////////////////
  /// rep cone : ///////////////////////
  //////////////////////////////////////
  } else if( (_style.modeling.value()==inlib::sg::modeling_cone()) ||
             (_style.modeling.value()==inlib::sg::modeling_cone_detector()) ){

    float cone_length = 1;
   {const inlib::xml::styles::style_t* sty = a_gv.styles().find_style("MCTrack_cone");
    if(sty) {
      inlib_vforcit(inlib::xml::styles::style_item_t,*sty,vit) {
        if((*vit).first=="length")     {if(!inlib::to<float>((*vit).second,cone_length,1)) {}}
      }
    }}

    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,cone_length,)

    float time_cone_elapse;
    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,time_cone_elapse,)

    if(cut_tracks.size()) {

      inlib::vec3f mean_pos;
      inlib::vec3f mean_p;
     {inlib::vec3f pos;
      inlib::vec3f p;
      inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
        const EsbMCTrack& _track = *(*it);
        pos.set_value(_track.GetStartX(),_track.GetStartY(),_track.GetStartZ());
        mean_pos += pos;
        p.set_value(_track.GetPx(),_track.GetPy(),_track.GetPz());
        mean_p += p;
      }
      mean_pos.divide(float(cut_tracks.size()));
      mean_p.divide(float(cut_tracks.size()));}

      if(mean_p.length()<=0.0f) {
        a_gv.out() << "EsbRootView::MCTrack_vis : mean_p.length()<=0." << std::endl;
      } else {

      float mean_angle = 0;
      float mean_time = 0;
      float S_p = 0;
      //size_t S_angle_num = 0;
     {inlib::vec3f p;
      inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
        const EsbMCTrack& _track = *(*it);
        p.set_value(_track.GetPx(),_track.GetPy(),_track.GetPz());
        float _p = _track.GetP();
        float cos_angle;
        if(!mean_p.cos_angle(p,cos_angle)) {
          a_gv.out() << "EsbRootView::MCTrack_vis : mean_p.cos_angle(p) failed." << std::endl;
        } else {
          float angle = inlib::facos(cos_angle);
          mean_angle += angle*_p;
          //S_angle_num++;
          S_p += _p;
          mean_time += _track.GetStartT()*_p;
	}
      }}

    //if(S_angle_num) {
      if(S_p) {

    //S_angle /= float(S_angle_num);
      mean_angle /= float(S_p);
      mean_time /= float(S_p);

    //::printf("debug : cone : 000 : p %g %g %g, mean angle %g, mean time %g\n",mean_p.x(),mean_p.y(),mean_p.z(),mean_angle,mean_time);

      if(mean_angle>=inlib::fhalf_pi()) {
      //a_gv.insh().warn("EsbRootView::MCTrack_vis : angle>pi/2");
        a_gv.out() << "EsbRootView::MCTrack_vis : angle ("<< mean_angle << ") >pi/2." << std::endl;
      } else {
        if(anim) {
          inlib::sg::rgba* mat = new inlib::sg::rgba();
          mat->color = _style.color.value();
          sep->add(mat);

          sep->add(new inlib::sg::matrix);  //for move_manip.

	  float time_cone_begin = mean_time;

          if(_style.modeling.value()==inlib::sg::modeling_cone_detector()) {
            float det_diameter = 2*_dac->wc_radius();
            float det_length = _dac->wc_length();
            float det_max_time = inlib::fsqrt(det_diameter*det_diameter+det_length*det_length)/speed;  //nsecs.

            inlib::sg::hep_cone_anim* _anim = new inlib::sg::hep_cone_anim();
            _anim->position = mean_pos;
            _anim->direction = mean_p;
            _anim->angle = mean_angle;
            _anim->time_cone_begin = time_cone_begin;
            _anim->time_cone_elapse = det_max_time*10;
            _anim->speed = speed;

            inlib::hep::polyhedron_tube cylinder(0,det_diameter*0.5f,det_length*0.5f,48);

            inlib::hep::tsf_polyhedron(cylinder,_dac->wc_matrix());

            _anim->operand = cylinder;
            _anim->operation = inlib::sg::solid_intersection;

            sep->add(_anim);

          } else {
            inlib::sg::cone_anim* _anim = new inlib::sg::cone_anim();
            _anim->position = mean_pos;
            _anim->direction = mean_p;
            _anim->angle = mean_angle;
            _anim->time_cone_begin = time_cone_begin;
            _anim->time_cone_elapse = time_cone_elapse;
            _anim->speed = speed;
            sep->add(_anim);
	  }

          empty = false;

       } else {
          inlib::sg::rgba* mat = new inlib::sg::rgba();
          mat->color = _style.color.value();
          sep->add(mat);

          if(_style.modeling.value()==inlib::sg::modeling_cone_detector()) {
            float det_diameter = 2*_dac->wc_radius();
            float det_length = _dac->wc_length();
            float det_max_length = inlib::fsqrt(det_diameter*det_diameter+det_length*det_length);

            float height = det_max_length*10;
            float rmax = inlib::ftan(mean_angle)*height;

            inlib::hep::polyhedron_cone cone(0,rmax,0,0,height*0.5f,48);
            cone.Translate(0,0,-height*0.5f); //applied first.
            inlib::vec3d to(mean_p.x(),mean_p.y(),mean_p.z());
            cone.Transform(inlib::rotd(inlib::vec3d(0,0,-1),to),mean_pos.x(),mean_pos.y(),mean_pos.z()); //rotate then translate.

            inlib::hep::polyhedron_tube cylinder(0,det_diameter*0.5f,det_length*0.5f,48);

            inlib::hep::tsf_polyhedron(cylinder,_dac->wc_matrix());

            inlib::hep::polyhedron op = cone.intersect(cylinder);

            inlib::sg::polyhedron* polyhedron = new inlib::sg::polyhedron;
            polyhedron->ph = op;
            sep->add(polyhedron);
            empty = false;

          } else if(cone_length>0.0f) {
            float height = cone_length;
            float rmax = inlib::ftan(mean_angle)*height;

            inlib::sg::matrix* mtx = new inlib::sg::matrix;
            mtx->set_translate(mean_pos);
            mtx->mul_rotate(inlib::vec3f(0,0,-1),mean_p);
            mtx->mul_translate(0,0,-height*0.5f); //applied first.
            sep->add(mtx);

            inlib::sg::cone_hat* cone = new inlib::sg::cone_hat;
            cone->height = height;
            cone->rmin = 0;
            cone->rmax = rmax;
            sep->add(cone);
            empty = false;
          }

        }

      } //mean_angle>pi/2
      } //S_p
      } //mean_p.length()
    }

  //////////////////////////////////////
  /// rep firework : ///////////////////
  //////////////////////////////////////
  } else if(_style.modeling.value()==inlib::sg::modeling_firework()) {

    float absorption_length = absorption_length_water;
    INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,absorption_length,)
    if(absorption_length<0) absorption_length = absorption_length_water;

    bool persistent = false;
    INLIB_GUI_VIEWER_GET_ARG_BOOL(MCTrack_vis,persistent,)

    bool dcut = false;
    INLIB_GUI_VIEWER_GET_ARG_BOOL(MCTrack_vis,dcut,)

    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    if(persistent) {
      ds->style = inlib::sg::draw_lines;
      ds->line_width = _style.line_width;
    } else {
      ds->style = inlib::sg::draw_points;
      ds->point_size = _style.point_size;
    }
    sep->add(ds);

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = _style.color.value();
    sep->add(mat);

    sep->add(new inlib::sg::matrix);  //for move_manip.

    const inlib::mat4d& dac_mtx = _dac->wc_matrix();
    inlib::mat4f da_mtxf(
      float(dac_mtx.v00()),float(dac_mtx.v01()),float(dac_mtx.v02()),float(dac_mtx.v03()),
      float(dac_mtx.v10()),float(dac_mtx.v11()),float(dac_mtx.v12()),float(dac_mtx.v13()),
      float(dac_mtx.v20()),float(dac_mtx.v21()),float(dac_mtx.v22()),float(dac_mtx.v23()),
      float(dac_mtx.v30()),float(dac_mtx.v31()),float(dac_mtx.v32()),float(dac_mtx.v33()) );

    float rate = 1.0f/absorption_length;
    inlib::rexpf re(rate);

    if(persistent) {
      float text_scale = 4;
      INLIB_GUI_VIEWER_GET_ARG_FLOAT(MCTrack_vis,text_scale,)

      inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
        double p = (*it)->GetP();
        if(!p) continue;

        firework_anim* _anim =
          new firework_anim(da_mtxf,_dac->wc_radius(),_dac->wc_length(),(*it)->name(),text_scale);
        _anim->persistent = true;
        _anim->dcut = dcut;
        _anim->speed = speed;

        //_anim->name = (*it)->name();
        //_anim->text_scale = text_scale;

        sep->add(_anim);

        std::vector<float>& _v = _anim->xyztn.values();
        _v.push_back(float((*it)->GetStartX()));
        _v.push_back(float((*it)->GetStartY()));
        _v.push_back(float((*it)->GetStartZ()));
        _v.push_back(float((*it)->GetStartT()));
        _v.push_back(float((*it)->GetPx()/p));
        _v.push_back(float((*it)->GetPy()/p));
        _v.push_back(float((*it)->GetPz()/p));
        _v.push_back(re.shoot());

        _anim->xyztn.touch();
      }

    } else {
      firework_anim* _anim = new firework_anim(da_mtxf,_dac->wc_radius(),_dac->wc_length());
      _anim->persistent = false;
      _anim->dcut = dcut;
      _anim->speed = speed;
      sep->add(_anim);

      std::vector<float>& _v = _anim->xyztn.values();
      _v.reserve(7*cut_tracks.size());
      inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
        double p = (*it)->GetP();
        if(!p) continue;
        _v.push_back(float((*it)->GetStartX()));
        _v.push_back(float((*it)->GetStartY()));
        _v.push_back(float((*it)->GetStartZ()));
        _v.push_back(float((*it)->GetStartT()));
        _v.push_back(float((*it)->GetPx()/p));
        _v.push_back(float((*it)->GetPy()/p));
        _v.push_back(float((*it)->GetPz()/p));
        _v.push_back(re.shoot());
      }

      _anim->xyztn.touch();

    }

    empty = false;

  //////////////////////////////////////
  /// rep point : //////////////////////
  //////////////////////////////////////
  } else if(_style.modeling.value()==inlib::sg::modeling_markers()) {

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = _style.color.value();
    sep->add(mat);

    sep->add(new inlib::sg::matrix);  //for move_manip.

    inlib::sg::markers* _marks = new inlib::sg::markers;
    _marks->size = _style.marker_size;
    _marks->style = _style.marker_style;
   {inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
      _marks->add(float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()));
    }}
    sep->add(_marks);  

    empty = false;

  } else if(_style.modeling.value().empty()) {

    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->style = inlib::sg::draw_points;
    ds->point_size = _style.point_size;
    sep->add(ds);

    if(anim) {
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = _style.color.value();
      sep->add(mat);

      sep->add(new inlib::sg::matrix);  //for move_manip.

      std::vector<inlib::vec4f> xyzts;
     {inlib_vforcit(EsbMCTrack*,cut_tracks,it)
       xyzts.push_back(inlib::vec4f
         (float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()),float((*it)->GetStartT())));}

      sep->add(new inlib::sg::xyzt_anim(xyzts));

      empty = false;

    } else if(_cmap) {

      if(_style.pickable) {
        inlib::colorf _color;
        double value;

        inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
          inlib::sg::atb_vertices* vtxs;
          sep->add(create_sg_pickable(a_gv,_eval_cut,*(*it),vtxs));
          if(!_eval_coloring.evaluate_double(*(*it),value)) {}
          _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
          vtxs->add_pos_color(float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()),_color);
          empty = false;
        }

      } else {
        sep->add(new inlib::sg::matrix);  //for move_manip.

        inlib::sg::atb_vertices* vtxs = new inlib::sg::atb_vertices;
        vtxs->mode = inlib::gl::points();
        sep->add(vtxs);

        inlib::colorf _color;
        double value;

        inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
          if(!_eval_coloring.evaluate_double(*(*it),value)) {}
          _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
          vtxs->add_pos_color(float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()),_color);
          empty = false;
        }
      }

    } else {
      if(_style.pickable) {

        inlib::sg::rgba* mat = new inlib::sg::rgba();
        mat->color = _style.color.value();
        sep->add(mat);

        inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
          inlib::sg::vertices* vtxs;
          sep->add(create_sg_pickable(a_gv,_eval_cut,*(*it),vtxs));
          vtxs->add(float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()));
          empty = false;
        }

      } else {
        sep->add(new inlib::sg::matrix);  //for move_manip.

        inlib::sg::rgba* mat = new inlib::sg::rgba();
        mat->color = _style.color.value();
        sep->add(mat);

        inlib::sg::vertices* vtxs = new inlib::sg::vertices;
        vtxs->mode = inlib::gl::points();
        sep->add(vtxs);

        inlib_vforcit(EsbMCTrack*,cut_tracks,it) {
          vtxs->add(float((*it)->GetStartX()),float((*it)->GetStartY()),float((*it)->GetStartZ()));
          empty = false;
        }

      }
    }
  } else {
    a_gv.insh().warn("EsbRootView::MCTrackt_vis : unknown modeling style "+_style.modeling.value()+".");
  }

  delete _cmap;
  delete _eval_arrow_length;

  if(empty) {delete sep;return;}

  place_sep(*_evd,sep);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// DetectorPoints : /////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void count_DetectorPoints(inlib::sg::gui_viewer& a_gv,
                                 const one_event& a_event,const std::vector<EsbDetectorPoint*>& a_points,
				 const std::string& a_style,const std::vector<std::string>& a_args) {
  //const std::vector<EsbMCTrack*>& tracks = a_event.mc_tracks();

  const std::vector<EsbDetectorPoint*>& points = a_points;

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),a_style,_args,_style);

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbDetectorPoint_evaluator _eval_cut(a_gv.out(),_style.cut.value(),a_event);
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::count_DetectorPoints : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  size_t count = 0;
  if(_style.cut.value().empty()) {
    count = points.size();
  } else {
    bool ok;
    inlib_vforcit(EsbDetectorPoint*,points,it) {
      if(!_eval_cut.accept(*(*it),ok)) {count=0;break;}
      if(ok) count++;
    }
  }

  if(a_gv.insh().in_backquote()) {
    a_gv.insh().out_size_t(count);
  } else {
    a_gv.out () << a_style << " with cut " << inlib::sout(_style.cut.value()) << " = " << count << std::endl;
  }
}

inline void print_DetectorPoints(inlib::sg::gui_viewer& a_gv,
                                const one_event& a_event,const std::vector<EsbDetectorPoint*>& a_points,
				const std::string& a_style,const std::vector<std::string>& a_args) {
  //const std::vector<EsbMCTrack*>& tracks = a_event.mc_tracks();

  const std::vector<EsbDetectorPoint*>& points = a_points;

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),a_style,_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbDetectorPoint_evaluator _eval_cut(a_gv.out(),_style.cut.value(),a_event);
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::print_DetectorPoints : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbDetectorPoint*> cut_points;
  if(_style.cut.value().empty()) {
    cut_points = points;
  } else {
    bool ok;
    inlib_vforcit(EsbDetectorPoint*,points,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_points.clear();break;}
      if(ok) cut_points.push_back(*it);
    }
  }

  std::string sheader = a_style+" (";
  inlib::size_tas(cut_points.size(),sheader);
  sheader += ") with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";

 {std::vector<std::string> vout;
  if(a_gv.insh().in_backquote()) {
    _eval_cut.dump(a_gv.out(),cut_points,names,sheader,true,vout);
    a_gv.insh().out_begin();
    a_gv.insh().out(vout,true);
  } else {
    _eval_cut.dump(a_gv.out(),cut_points,names,sheader,false,vout);
  }}
}

inline void stats_DetectorPoints(inlib::sg::gui_viewer& a_gv,
                                 const one_event& a_event,const std::vector<EsbDetectorPoint*>& a_points,
                                 const std::string& a_style,const std::vector<std::string>& a_args) {
  //const std::vector<EsbMCTrack*>& tracks = a_event.mc_tracks();

  const std::vector<EsbDetectorPoint*>& points = a_points;

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),a_style,_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  std::string stats_arg;
  if(_args.is_arg("-sum"))  stats_arg = "sum";
  if(_args.is_arg("-min"))  stats_arg = "min";
  if(_args.is_arg("-max"))  stats_arg = "max";
  if(_args.is_arg("-mean")) stats_arg = "mean";
  if(_args.is_arg("-rms"))  stats_arg = "rms";
  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbDetectorPoint_evaluator _eval_cut(a_gv.out(),_style.cut.value(),a_event);
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::stats_DetectorPoints : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbDetectorPoint*> cut_points;
  if(_style.cut.value().empty()) {
    cut_points = points;
  } else {
    bool ok;
    inlib_vforcit(EsbDetectorPoint*,points,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_points.clear();break;}
      if(ok) cut_points.push_back(*it);
    }
  }

  std::string sheader = a_style+" (";
  inlib::size_tas(cut_points.size(),sheader);
  sheader += ") sum/min/max/mean/rms with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";

  std::string sout;
  _eval_cut.stats(a_gv.out(),cut_points,names,sheader,stats_arg,sout);
  if(sout.size()) a_gv.insh().out(sout);
}

inline void vis_DetectorPoints(inlib::sg::gui_viewer& a_gv,
                               const one_event& a_event,const std::vector<EsbDetectorPoint*>& a_points,
			       const std::string& a_style,const std::vector<std::string>& a_args) {
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) {a_gv.insh().warn("EsbRootView::vis_DetectorPoint : bad evd cast.");return;}
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::vis_DetectorPoint : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  _style.modeling.value().clear();
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),a_style,_args,_style);

  bool anim = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(MCTrack_vis,anim,)

//std::string splacement_object;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_object)
//std::string splacement_class;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_class)

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbDetectorPoint_evaluator _eval_cut(a_gv.out(),_style.cut.value(),a_event);
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::vis_DetectorPoints : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbDetectorPoint*> cut_points;
  if(_style.cut.value().empty()) {
    cut_points = a_points;
  } else {
    bool ok;
    inlib_vforcit(EsbDetectorPoint*,a_points,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_points.clear();break;}
      if(ok) cut_points.push_back(*it);
    }
  }

  inlib::sg::base_colormap* _cmap = 0;
  double _min_coloring,_max_coloring,_range_coloring;
  EsbDetectorPoint_evaluator _eval_coloring(a_gv.out(),_style.coloring.value(),a_event);
  if(_style.coloring.value().size()) {
    if(!_eval_coloring.is_valid()) {
      a_gv.insh().warn("EsbRootView::vis_DetectorPoints : bad script "+inlib::sout(_style.coloring.value())+" for coloring evaluator.");
      return;
    }
    _cmap = inlib::get_colormap(a_gv.out(),_style,a_gv.styles().cmaps(),cut_points,_eval_coloring,_min_coloring,_max_coloring);
    _range_coloring = _max_coloring-_min_coloring;
  }

  //////////////////////////////////////
  //////////////////////////////////////
  //////////////////////////////////////

  inlib::sg::separator* sep = new inlib::sg::separator;
  bool empty = true;

  if(_style.modeling==inlib::sg::modeling_detector()) {  // have a hedgehog rep.
    float p_max = 0;
    inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
      p_max = inlib::mx<float>(p_max,(*it)->GetP());
    }
    if(p_max<=0) {
      delete sep;
      return;
    }

    double wc_radius = _dac->wc_radius();
    double wc_length = _dac->wc_length();
    float rep_length = float(wc_length)*0.5f;
    inlib::mat4d wc_inv;_dac->wc_matrix().invert(wc_inv);
    double epsilon = wc_radius*1e-6;

    const inlib::mat4d& dac_mtx = _dac->wc_matrix();
    inlib::mat4f da_mtxf(
      float(dac_mtx.v00()),float(dac_mtx.v01()),float(dac_mtx.v02()),float(dac_mtx.v03()),
      float(dac_mtx.v10()),float(dac_mtx.v11()),float(dac_mtx.v12()),float(dac_mtx.v13()),
      float(dac_mtx.v20()),float(dac_mtx.v21()),float(dac_mtx.v22()),float(dac_mtx.v23()),
      float(dac_mtx.v30()),float(dac_mtx.v31()),float(dac_mtx.v32()),float(dac_mtx.v33()) );


    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->style = inlib::sg::draw_lines;
    ds->line_width = _style.line_width;
    sep->add(ds);

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = _style.color.value();
    sep->add(mat);

    inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
      const EsbDetectorPoint* point = *it;
      float length = rep_length*float(point->GetP())/p_max;

    //length = rep_length; //for debugging.

      double x = point->GetX();
      double y = point->GetY();
      double z = point->GetZ();
      double w = 1;
      wc_inv.mul_4(x,y,z,w);
      int location;
      if(!get_location(wc_radius,wc_length,epsilon,x,y,z,location)) {}

      inlib::sg::separator* _sep = new inlib::sg::separator;
      sep->add(_sep);

      inlib::sg::matrix* _matrix = new inlib::sg::matrix;
      _sep->add(_matrix);

      inlib::sg::vertices* vtxs = new inlib::sg::vertices;
      vtxs->mode = inlib::gl::lines();
      vtxs->add(0,0,0);
      vtxs->add(0,0,length);
      _sep->add(vtxs);

      empty = false;

      _matrix->mtx = da_mtxf;

      if(location==1) { //front
        _matrix->mul_translate(x,y,z);
      } else if(location==2) { //side
        _matrix->mul_translate(x,y,z);
        _matrix->mul_rotate(inlib::vec3f(1,0,0),inlib::vec3f(x,y,0));
        _matrix->mul_rotate(0,1,0,inlib::fhalf_pi());  //bring shape along x.
      } else if(location==3) { //back
        _matrix->mul_translate(x,y,z-length);
      }
    }

  } else { //_style.modeling.

  inlib::sg::draw_style* ds = new inlib::sg::draw_style;
  ds->style = inlib::sg::draw_points;
  ds->point_size = _style.point_size;
  sep->add(ds);

  if(anim) {
    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = _style.color.value();
    sep->add(mat);

    sep->add(new inlib::sg::matrix);  //for move_manip.

    std::vector<inlib::vec4f> xyzts;
   {inlib_vforcit(EsbDetectorPoint*,cut_points,it)
      xyzts.push_back(inlib::vec4f(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()),float((*it)->GetTime())));}

    sep->add(new inlib::sg::xyzt_anim(xyzts));

    empty = false;

  } else if(_style.pickable) {
    inlib::colorf _color;
    double value;
    std::vector<std::string> vinfos;

    inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
      inlib::sg::atb_vertices* vtxs;
      sep->add(create_sg_pickable(a_gv,_eval_cut,*(*it),vtxs));
      if(_cmap) {
        if(!_eval_coloring.evaluate_double(*(*it),value)) {}
        _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
        vtxs->add_pos_color(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()),_color);
      } else {
        vtxs->add_pos_color(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()),_style.color.value());
      }

      empty = false;
    }

  } else {

    sep->add(new inlib::sg::matrix);  //for move_manip.

    if(_cmap) {
      inlib::colorf _color;
      double value;

      inlib::sg::atb_vertices* vtxs = new inlib::sg::atb_vertices;
      vtxs->mode = inlib::gl::points();
      sep->add(vtxs);

      if(_style.modeling.value()==s_modeling_mc_track()) {
        inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
          if(!_eval_coloring.evaluate_double(*(*it),value)) {}
          _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
          int track_id = (*it)->GetTrackID();
          if((track_id<0)||(track_id>=int(a_event.mc_tracks().size())))  {
            a_gv.out() << "EsbRootView::vis_DetectorPoints : a point with a bad track ID (" << track_id << ")." << std::endl;
	  } else {
            const EsbMCTrack* track = a_event.mc_tracks()[track_id];
            vtxs->add_pos_color(float(track->GetStartX()),float(track->GetStartY()),float(track->GetStartZ()),_color);
            empty = false;
	  }
        }
      } else if(_style.modeling.value().empty()) {
        inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
          if(!_eval_coloring.evaluate_double(*(*it),value)) {}
          _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
          vtxs->add_pos_color(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()),_color);
          empty = false;
        }
      } else {
        a_gv.insh().warn("EsbRootView::vis_DetectorPoint : unknown modeling style "+_style.modeling.value()+".");
      }

    } else {
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = _style.color.value();
      sep->add(mat);

      inlib::sg::vertices* vtxs = new inlib::sg::vertices;
      vtxs->mode = inlib::gl::points();
      sep->add(vtxs);

      if(_style.modeling.value()==s_modeling_mc_track()) {
        inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
          int track_id = (*it)->GetTrackID();
          if((track_id<0)||(track_id>=int(a_event.mc_tracks().size())))  {
            a_gv.out() << "EsbRootView::vis_DetectorPoints : a point with a bad track ID (" << track_id << ")." << std::endl;
	  } else {
            const EsbMCTrack* track = a_event.mc_tracks()[track_id];
            vtxs->add(float(track->GetStartX()),float(track->GetStartY()),float(track->GetStartZ()));
            empty = false;
	  }
        }
      } else if(_style.modeling.value().empty()) {
        inlib_vforcit(EsbDetectorPoint*,cut_points,it) {
          vtxs->add(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()));
          empty = false;
        }
      } else {
        a_gv.insh().warn("EsbRootView::vis_DetectorPoint : unknown modeling style "+_style.modeling.value()+".");
      }
    }
  }

  delete _cmap;

  } //_style.modeling.

  if(empty) {delete sep;return;}

  place_sep(*_evd,sep);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// WCDetectorPoint : ////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void WCDetectorPoint_count(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::WCDetectorPoint_count : bad dac cast.");return;}
  count_DetectorPoints(a_gv,_dac->event(),_dac->event().wc_points(),"WCDetectorPoint",a_args);
}

inline void WCDetectorPoint_print(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::WCDetectorPoint_print : bad dac cast.");return;}
  print_DetectorPoints(a_gv,_dac->event(),_dac->event().wc_points(),"WCDetectorPoint",a_args);
}
inline void WCDetectorPoint_stats(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::WCDetectorPoint_stats : bad dac cast.");return;}
  stats_DetectorPoints(a_gv,_dac->event(),_dac->event().wc_points(),"WCDetectorPoint",a_args);
}

inline void WCDetectorPoint_vis(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;
  vis_DetectorPoints(a_gv,_dac->event(),_dac->event().wc_points(),"WCDetectorPoint",a_args);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FgdDetectorPoint : ////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void FgdDetectorPoint_count(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdDetectorPoint_count : bad dac cast.");return;}
  count_DetectorPoints(a_gv,_dac->event(),_dac->event().fgd_points(),"FgdDetectorPoint",a_args);
}
inline void FgdDetectorPoint_print(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdDetectorPoint_print : bad dac cast.");return;}
  print_DetectorPoints(a_gv,_dac->event(),_dac->event().fgd_points(),"FgdDetectorPoint",a_args);
}
inline void FgdDetectorPoint_stats(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdDetectorPoint_stats : bad dac cast.");return;}
  stats_DetectorPoints(a_gv,_dac->event(),_dac->event().fgd_points(),"FgdDetectorPoint",a_args);
}
inline void FgdDetectorPoint_vis(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;
  vis_DetectorPoints(a_gv,_dac->event(),_dac->event().fgd_points(),"FgdDetectorPoint",a_args);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FgdHit : /////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void FgdHit_count(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdHit_count : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"FgdHit",_args,_style);

  //////////////////////////////////////
  /// unique : /////////////////////////
  //////////////////////////////////////
  bool unique_at_pos = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_count,unique_at_pos,)
  bool unique_verbose = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_count,unique_verbose,)

  std::vector<EsbFgdHit*> unique_hits;
  bool unique_to_clear = false;
  if(unique_at_pos) {
    FgdHits_unique_at_pos(a_gv.out(),_dac->event().fgd_hits(),unique_hits,unique_verbose);
    unique_to_clear = true;
  } else {
    unique_hits = _dac->event().fgd_hits();
  }

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbFgdHit_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::FgdHit_count : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  size_t count = 0;
  if(_style.cut.value().empty()) {
    count = unique_hits.size();
  } else {
    bool ok;
    inlib_vforcit(EsbFgdHit*,unique_hits,it) {
      if(!_eval_cut.accept(*(*it),ok)) {count = 0;break;}
      if(ok) count++;
    }
  }

  ///////////////////////////////////////////
  ///////////////////////////////////////////
  ///////////////////////////////////////////

  if(a_gv.insh().in_backquote()) {
    a_gv.insh().out_size_t(count);
  } else {
    a_gv.out () << "FgdHit with cut " << inlib::sout(_style.cut.value()) << " = " << count << std::endl;
  }

  if(unique_to_clear) inlib::raw_clear(unique_hits);
}

inline void FgdHit_print(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdHit_print : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"FgdHit",_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  //////////////////////////////////////
  /// unique : /////////////////////////
  //////////////////////////////////////
  bool unique_at_pos = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_print,unique_at_pos,)
  bool unique_verbose = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_print,unique_verbose,)

  std::vector<EsbFgdHit*> unique_hits;
  bool unique_to_clear = false;
  if(unique_at_pos) {
    FgdHits_unique_at_pos(a_gv.out(),_dac->event().fgd_hits(),unique_hits,unique_verbose);
    unique_to_clear = true;
  } else {
    unique_hits = _dac->event().fgd_hits();
  }

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbFgdHit_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::FgdHit_print : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbFgdHit*> cut_hits;
  if(_style.cut.value().empty()) {
    cut_hits = unique_hits;
  } else {
    bool ok;
    inlib_vforcit(EsbFgdHit*,unique_hits,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_hits.clear();break;}
      if(ok) cut_hits.push_back(*it);
    }
  }

  ///////////////////////////////////////////
  ///////////////////////////////////////////
  ///////////////////////////////////////////

  std::string sheader = "FgdHit (";
  inlib::size_tas(cut_hits.size(),sheader);
  sheader += ") with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";

 {std::vector<std::string> vout;
  if(a_gv.insh().in_backquote()) {
    _eval_cut.dump(a_gv.out(),cut_hits,names,sheader,true,vout);
    a_gv.insh().out_begin();
    a_gv.insh().out(vout,true);
  } else {
    _eval_cut.dump(a_gv.out(),cut_hits,names,sheader,false,vout);
  }}

  if(unique_to_clear) inlib::raw_clear(unique_hits);
}

inline void FgdHit_stats(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdHit_stats : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"FgdHit",_args,_style);

  std::vector<std::string> names;
  _args.not_hyphens(names);

  std::string stats_arg;
  if(_args.is_arg("-sum"))  stats_arg = "sum";
  if(_args.is_arg("-min"))  stats_arg = "min";
  if(_args.is_arg("-max"))  stats_arg = "max";
  if(_args.is_arg("-mean")) stats_arg = "mean";
  if(_args.is_arg("-rms"))  stats_arg = "rms";
  //////////////////////////////////////
  /// unique : /////////////////////////
  //////////////////////////////////////
  bool unique_at_pos = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_stats,unique_at_pos,)
  bool unique_verbose = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_stats,unique_verbose,)

  std::vector<EsbFgdHit*> unique_hits;
  bool unique_to_clear = false;
  if(unique_at_pos) {
    FgdHits_unique_at_pos(a_gv.out(),_dac->event().fgd_hits(),unique_hits,unique_verbose);
    unique_to_clear = true;
  } else {
    unique_hits = _dac->event().fgd_hits();
  }

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbFgdHit_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::FgdHit_stats : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbFgdHit*> cut_hits;
  if(_style.cut.value().empty()) {
    cut_hits = unique_hits;
  } else {
    bool ok;
    inlib_vforcit(EsbFgdHit*,unique_hits,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_hits.clear();break;}
      if(ok) cut_hits.push_back(*it);
    }
  }

  ///////////////////////////////////////////
  ///////////////////////////////////////////
  ///////////////////////////////////////////

  std::string sheader = "FgdHit (";
  inlib::size_tas(cut_hits.size(),sheader);
  sheader += ") sum/min/max/mean/rms with cut ";
  sheader += inlib::sout(_style.cut.value())+" : ";


  std::string sout;
  _eval_cut.stats(a_gv.out(),cut_hits,names,sheader,stats_arg,sout);
  if(sout.size()) a_gv.insh().out(sout);

  if(unique_to_clear) inlib::raw_clear(unique_hits);
}

/*
#include <cstdlib> //qsort
extern "C" {
  typedef int (*EsbRootView_sort_func_t)(const void*,const void*);
}
typedef EsbFgdHit* fgd_item;
inline int fgd_greater(fgd_item* a_1,fgd_item* a_2){
  if((*a_1)->GetZ()==(*a_2)->GetZ()) return 0;
  return (*a_1)->GetZ()>(*a_2)->GetZ()?1:-1;
}
inline bool sort_by_z(std::vector<fgd_item>& a_vec) {
  size_t len = a_vec.size();
  if(len<=1) return true;
  fgd_item* items = inlib::vec_data(a_vec);
  ::qsort(items,len,sizeof(fgd_item),(EsbRootView_sort_func_t)fgd_greater);
  return true;
}
*/

inline void FgdHit_vis(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) {a_gv.insh().warn("EsbRootView::FgdHit_vis : bad evd cast.");return;}
  dac* _dac = cast_dac(a_gv);
  if(!_dac) {a_gv.insh().warn("EsbRootView::FgdHit_vis : bad dac cast.");return;}

  //////////////////////////////////////
  //// get style : /////////////////////
  //////////////////////////////////////

  inlib::sg::style _style;
  _style.modeling.value().clear();
  inlib::args _args(a_args);
  inlib::sg::get_style(a_gv.styles(),"FgdHit",_args,_style);

  std::string scube_size;

 {const inlib::xml::styles::style_t* sty = a_gv.styles().find_style("FgdHit_cube");
  if(sty) {
    inlib_vforcit(inlib::xml::styles::style_item_t,*sty,vit) {
      if((*vit).first=="size")   {scube_size = (*vit).second;}
    }
  }}

  INLIB_GUI_VIEWER_GET_ARG_STRING(cube_size)

//std::string splacement_object;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_object)
//std::string splacement_class;
//INLIB_GUI_VIEWER_GET_ARG_STRING(placement_class)

  //////////////////////////////////////
  /// unique : /////////////////////////
  //////////////////////////////////////
  bool unique_at_pos = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_vis,unique_at_pos,)
  bool unique_verbose = false;
  INLIB_GUI_VIEWER_GET_ARG_BOOL(FgdHit_vis,unique_verbose,)

  std::vector<EsbFgdHit*> unique_hits;
  bool unique_to_clear = false;
  if(unique_at_pos) {
    FgdHits_unique_at_pos(a_gv.out(),_dac->event().fgd_hits(),unique_hits,unique_verbose);
    unique_to_clear = true;
  } else {
    unique_hits = _dac->event().fgd_hits();
  }

  //////////////////////////////////////
  /// cut : ////////////////////////////
  //////////////////////////////////////
  EsbFgdHit_evaluator _eval_cut(a_gv.out(),_style.cut.value(),_dac->event());
  if(!_eval_cut.is_valid()) {
    a_gv.insh().warn("EsbRootView::FgdHit_vis : bad script "+inlib::sout(_style.cut.value())+" for cut evaluator.");
    return;
  }

  std::vector<EsbFgdHit*> cut_hits;
  if(_style.cut.value().empty()) {
    cut_hits = unique_hits;
  } else {
    bool ok;
    inlib_vforcit(EsbFgdHit*,unique_hits,it) {
      if(!_eval_cut.accept(*(*it),ok)) {cut_hits.clear();break;}
      if(ok) cut_hits.push_back(*it);
    }
  }

  ///////////////////////////////////////////
  /// building the representations : ////////
  ///////////////////////////////////////////

  if(_style.modeling.value()==inlib::sg::modeling_cube()) {
    //////////////////////////////////////
    /// modeling_cube : //////////////////
    //////////////////////////////////////
    inlib::sg::base_colormap* _cmap = 0;
    double _min_coloring,_max_coloring,_range_coloring;
    EsbFgdHit_evaluator _eval_coloring(a_gv.out(),_style.coloring.value(),_dac->event());
    if(_style.coloring.value().size()) {
      if(!_eval_coloring.is_valid()) {
        a_gv.insh().warn("EsbRootView::FgdHit_vis : bad script "+inlib::sout(_style.coloring.value())+" for coloring evaluator.");
        if(unique_to_clear) inlib::raw_clear(unique_hits);
        return;
      }
      _cmap = inlib::get_colormap(a_gv.out(),_style,a_gv.styles().cmaps(),cut_hits,_eval_coloring,_min_coloring,_max_coloring);
      _range_coloring = _max_coloring-_min_coloring;
    }

    EsbFgdHit_evaluator*  _eval_cube_size = 0;
    double _min_cube_size,_max_cube_size,_range_cube_size;
    double default_cube_size = 0.99; // not one so that cube is within Esb/SuperFGD volume. (It avoids bad coloring if SuperFGD is transparent).
    if(inlib::rm_eval_parenthesis(scube_size)) {
      _eval_cube_size = new EsbFgdHit_evaluator(a_gv.out(),scube_size,_dac->event());
      if(!_eval_cube_size->evaluate_double_min_max(cut_hits,_min_cube_size,_max_cube_size)) {
        _range_cube_size = -1;
      } else {
        _range_cube_size = _max_cube_size-_min_cube_size;
      }
    } else {
      if(!inlib::to<double>(scube_size,default_cube_size,0.99)) {}
    }

    //////////////////////////////////////
    //////////////////////////////////////
    //////////////////////////////////////

    inlib::sg::separator* sep = new inlib::sg::separator;

    sep->add(new inlib::sg::matrix);  //for move_manip.

  //if(_style.color.value().a()<1) sort_by_z(cut_hits);

    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->cull_face = false;
    ds->style = inlib::sg::draw_filled;
    if(_eval_cube_size && (_range_cube_size!=(-1))) ds->style = inlib::sg::draw_lines;
    sep->add(ds);

    if(_cmap) {
    } else {
      inlib::sg::rgba* mat = new inlib::sg::rgba();
      mat->color = _style.color.value();
      sep->add(mat);
    }

    inlib::colorf _color;

    inlib_vforcit(EsbFgdHit*,cut_hits,it) {
      inlib::sg::separator* _sep = new inlib::sg::separator;
      sep->add(_sep);

      _sep->add(create_sg_infos(a_gv,_eval_cut,*(*it)));

      if(_cmap) {
        double value;
        if(!_eval_coloring.evaluate_double(*(*it),value)) {}
        _cmap->get_color(float((value-_min_coloring)/_range_coloring),_color);
        //::printf("debug : %g : %g %g %g\n",float((value-_min_coloring)/_range_coloring),(*it)->m_mppc_x,(*it)->m_mppc_y,(*it)->m_mppc_z);

        inlib::sg::rgba* mat = new inlib::sg::rgba();
        mat->color = _color;
        _sep->add(mat);
      }

    //float x = float((*it)->mppc_x())-50+0.5f;      // it should match GetX().
    //float y = float((*it)->mppc_y())-50+0.5f;      // it should match GetY().
    //float z = float((*it)->mppc_z())-50+0.5f-550;  // it should match GetZ().

      inlib::sg::matrix* mtx = new inlib::sg::matrix;
      mtx->set_translate(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()));
      _sep->add(mtx);

      double cube_size = default_cube_size;
      if(_eval_cube_size) {
        if(_range_cube_size!=(-1)) {
          double dcube_size;
          if(!_eval_cube_size->evaluate_double(*(*it),dcube_size)) {}
          cube_size = 0.5+0.5*default_cube_size*(dcube_size-_min_cube_size)/_range_cube_size;   // [0.5,0.99]
        }
      }

      inlib::sg::cube* cube = new inlib::sg::cube;
      cube->width = float(cube_size);
      cube->height = float(cube_size);
      cube->depth = float(cube_size);
      _sep->add(cube);
    }

    delete _cmap;
    delete _eval_cube_size;

    place_sep(*_evd,sep);

  } else if(_style.modeling.value().empty()) {
    //////////////////////////////////////
    /// points : /////////////////////////
    //////////////////////////////////////
    inlib::sg::separator* sep = new inlib::sg::separator;

    sep->add(new inlib::sg::matrix);  //for move_manip.

    inlib::sg::draw_style* ds = new inlib::sg::draw_style;
    ds->style = inlib::sg::draw_points;
    ds->point_size = _style.point_size;
    sep->add(ds);

    inlib::sg::rgba* mat = new inlib::sg::rgba();
    mat->color = _style.color.value();
    sep->add(mat);

    inlib::sg::vertices* vtxs = new inlib::sg::vertices;
    vtxs->mode = inlib::gl::points();
    sep->add(vtxs);

    inlib_vforcit(EsbFgdHit*,cut_hits,it) vtxs->add(float((*it)->GetX()),float((*it)->GetY()),float((*it)->GetZ()));

    place_sep(*_evd,sep);

  } else {
    a_gv.insh().warn("EsbRootView::FgdHit_vis : unknown modeling style "+_style.modeling.value()+".");
  }

  if(unique_to_clear) inlib::raw_clear(unique_hits);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool source_event_insh(inlib::sg::gui_viewer& a_gv) {
  std::vector<std::string> lines;
  lines.push_back(". event.insh");
  a_gv.insh()._exec_lines(lines);
  return true;
}

inline void vis_next_event(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  inlib::sg::view_evd* _evd = inlib::sg::cast_view_evd(a_gv);
  if(!_evd) return;
  dac* _dac = cast_dac(a_gv);
  if(!_dac) return;
  inlib::uint64 available_events = _dac->number_of_events();
  if(!available_events) {
    a_gv.insh().warn("EsbRootView::vis_next_event : no event.");
    return;
  }
  inlib::args _args(a_args);
  unsigned int number = 1;
  INLIB_GUI_VIEWER_GET_ARG_UINT(vis_next_event,number,)
  bool no_exec = _args.is_arg("-no_exec");
  for(unsigned int i=0;i<number;i++) {
    if(_evd->event_index()>=(unsigned int)available_events) _evd->event_index() = 0;
    if(!_dac->read_one_event(_evd->event_index())) return;
    if(no_exec) {
    } else {
      if(!source_event_insh(a_gv)) return;
    }
    _evd->event_index()++;
  }
}

#define ESBROOTVIEW_FIELDS_ITEM(a__data,a__evaluator) \
inline bool a__data##_fields(inlib::sg::gui_viewer& a_gv,const std::vector<std::string>& a_args) {\
  Esb##a__evaluator##_evaluator _eval(a_gv.insh().out(),"",one_event());\
  std::vector<std::string> names;\
  _eval.get_names(names);\
  if(a_gv.insh().in_backquote()) {\
    a_gv.insh().out_begin();\
    a_gv.insh().out(names,true);\
  } else {\
    inlib::sort::sort(names);\
    a_gv.insh().unix_print(names);\
  }\
  return true;\
}

ESBROOTVIEW_FIELDS_ITEM(MCTrack,MCTrack)
ESBROOTVIEW_FIELDS_ITEM(WCDetectorPoint,DetectorPoint)
ESBROOTVIEW_FIELDS_ITEM(FgdDetectorPoint,DetectorPoint)
ESBROOTVIEW_FIELDS_ITEM(FgdHit,FgdHit)

#undef ESBROOTVIEW_FIELDS_ITEM

}

#endif

