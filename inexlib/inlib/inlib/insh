// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_insh
#define inlib_insh

#include "ishell"

#include "typedefs"
#include "file"
#include "args"
#include "svar"
#include "chars"
#include "vpair"
#include "srep"
#include "b2s"
#include "sep"
#include "vmanip"
#include "mapmanip"
#include "s2time"
#include "sconc"
#include "sinsh"
#include "sjust"
#include "num2s"
#include "sbeg"
#include "sort"
#include "uprint"
#include "dirs"

#include "sys/atime"
#include "sys/console" //windows.h

namespace inlib {

class insh : public virtual ishell {
  typedef ishell parent;
private:  
  INLIB_SCLASS(inlib::insh)
public: //ishell:
  virtual void warn(const std::string& a_string,bool a_to_stop = true) {
    m_out << a_string << std::endl;
    map_warn(a_string);
    if(a_to_stop) m_state.m_to_stop = true;
  }
  virtual void out_begin() {if(m_state.m_in_backquote) m_state.m_backquote_return.clear();}

  virtual void out(const std::string& a_s,bool a_append = false,bool a_endl = true)  {
    if(m_state.m_in_backquote) {
      if(a_append && a_s.size()) {
        if(m_state.m_backquote_return.size()) m_state.m_backquote_return += " ";
        m_state.m_backquote_return += a_s;
      } else {
        m_state.m_backquote_return = a_s;
      }
    } else {
      m_out << a_s;
      if(a_endl) m_out << std::endl; else m_out.flush();
    }
  }
  virtual void unix_print(const std::vector<std::string>& a_lines,size_t a_spaces = 2) const {
    size_t term_cols = 80;
    unsigned int _cols,_rows;
    if(console_size(_cols,_rows)) {term_cols = _cols;}
    uprint(m_out,term_cols,a_spaces,a_lines);
  }

  virtual std::ostream& out() const {return m_out;}
public:
  virtual void map_warn(const std::string& a_msg,bool /*a_warn*/ = true) {}
public:
  class variable {
#ifdef INLIB_MEM
    INLIB_SCLASS(inlib::insh::variable)
#endif
  public:
    variable(const std::string& a_value = std::string(),bool a_is_env = false)
    :m_value(a_value)
    ,m_is_env(a_is_env)
    {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    virtual ~variable(){
#ifdef INLIB_MEM
      mem::decrement(s_class().c_str());
#endif
    }
  public:
    variable(const variable& a_from)
    :m_value(a_from.m_value)
    ,m_is_env(a_from.m_is_env)
    {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    variable& operator=(const variable& a_from){
      m_value = a_from.m_value;
      m_is_env = a_from.m_is_env;
      return *this;
    }
  public:
    std::string m_value;
    bool m_is_env;
  };
  
  typedef std::pair<std::string,variable> var_t;
  typedef std::pair<std::string,std::string> alias_t;
  
  class state {
#ifdef INLIB_MEM
    INLIB_SCLASS(inlib::insh::state)
#endif
public:
    state(std::ostream& a_out)
    :m_out(a_out)
    ,m_to_stop(false)
    ,m_in_backquote(false)
    ,m_backquote_return()
    ,m_is_sourcing(false)
    ,m_to_return(false)
    ,m_vars()
    ,m_aliases()
    //,m_paths()
    ,m_set_v(false)
    ,m_set_x(false)
    ,m_set_n(false)
    ,m_set_d(false)
//  ,m_set_d(true)
    {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    virtual ~state(){
#ifdef INLIB_MEM
      mem::decrement(s_class().c_str());
#endif
    }
public:
    state(const state& a_from)
    :m_out(a_from.m_out)
    ,m_to_stop(a_from.m_to_stop)
    ,m_in_backquote(a_from.m_in_backquote)
    ,m_backquote_return(a_from.m_backquote_return)
    ,m_is_sourcing(a_from.m_is_sourcing)
    ,m_to_return(a_from.m_to_return)
    ,m_vars(a_from.m_vars)
    ,m_aliases(a_from.m_aliases)
    //,m_paths(a_from.m_paths)
    ,m_set_v(a_from.m_set_v)
    ,m_set_x(a_from.m_set_x)
    ,m_set_n(a_from.m_set_n)
    ,m_set_d(a_from.m_set_d)
    {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    state& operator=(const state& a_from){
      m_to_stop = a_from.m_to_stop;
      m_in_backquote = a_from.m_in_backquote;
      m_backquote_return = a_from.m_backquote_return;
      m_is_sourcing = a_from.m_is_sourcing;
      m_to_return = a_from.m_to_return;
      m_vars = a_from.m_vars;
      m_aliases = a_from.m_aliases;
      //m_paths = a_from.m_paths;
      m_set_v = a_from.m_set_v;
      m_set_x = a_from.m_set_x;
      m_set_n = a_from.m_set_n;
      m_set_d = a_from.m_set_d;
      return *this;
    }
  public:
    void add_variable(const std::string& a_variable,const std::string& a_value) {
      if(m_set_d) m_out << "inlib::insh::state::add_variable : " << sout(a_variable) << ", value " << sout(a_value) << std::endl;
      add<std::string,variable>(m_vars,a_variable,variable(a_value));
    }
    void remove_variable(const std::string& a_variable) {remove<std::string,variable>(m_vars,a_variable);}
    bool is_variable(const std::string& a_name) const {return is_key(m_vars,a_name);}
    bool find_variable(const std::string& a_variable,std::string& a_value) const {
      variable _var;
      if(!find<std::string,variable>(m_vars,a_variable,_var)) {a_value.clear();return false;}
      a_value = _var.m_value;
      return true;
    }

    bool is_alias(const std::string& a_name) const {return is_key(m_aliases,a_name);}
    void add_alias(const std::string& a_alias,const std::string& a_value) {
      if(m_set_d) m_out << "inlib::insh::state::add_alias : " << sout(a_alias) << ", value " << sout(a_value) << std::endl;
      add<std::string,std::string>(m_aliases,a_alias,a_value);
    }
    void remove_alias(const std::string& a_alias) {remove<std::string,std::string>(m_aliases,a_alias);}
    bool find_alias(const std::string& a_alias,std::string& a_value) const {
      return find<std::string,std::string>(m_aliases,a_alias,a_value);
    }
  
    void add_env(const std::string& a_env,const std::string& a_value) {
      if(m_set_d) m_out << "inlib::insh::state::add_env : " << sout(a_env) << ", value " << sout(a_value) << std::endl;
      inlib_vforit(var_t,m_vars,it) {
        if((*it).first==a_env) {
          (*it).second.m_is_env = true;
          (*it).second.m_value = a_value;
          return;
        }
      }
      add<std::string,variable>(m_vars,a_env,variable(a_value,true));
    }
    /*
    void remove_env(const std::string& a_env) {
      inlib_vforit(var_t,m_vars,it) {
        if( ((*it).second.m_is_env) && ((*it).first==a_env) ) {
          m_vars.erase(it);
          return;
        }
      }
    }
    */
    bool set_as_env(const std::string& a_env) {
      inlib_vforit(var_t,m_vars,it) {
        if((*it).first==a_env) {
          (*it).second.m_is_env = true;
          return true;
        }
      }
      return false;
    }
  //bool is_env(const std::string& a_env) const {return is_in(m_envs,a_env);}
    
    bool find_env(const std::string& a_env,std::string& a_value) const {
      inlib_vforcit(var_t,m_vars,it) {
        if( ((*it).second.m_is_env) && ((*it).first==a_env) ){
          a_value = (*it).second.m_value;
          return true;
        }
      }
      a_value.clear();
      return false;
    }

    void find_paths(std::vector<std::string>& a_paths) const {
      std::string value;
      if(!find_env("PATH",value)) {a_paths.clear();return;}
      words(value,":",false,a_paths);
    }
  public:
    std::ostream& m_out;
    bool m_to_stop;
    bool m_in_backquote;
    std::string m_backquote_return;
    bool m_is_sourcing;
    bool m_to_return;
    std::vector<var_t> m_vars;
    std::vector<alias_t> m_aliases;
    //std::vector<std::string> m_paths;
    bool m_set_v;
    bool m_set_x;
    bool m_set_n;
    bool m_set_d;
  };
  const state& get_state() const {return m_state;}
protected:  
  void pop_state() {
    m_state = m_states.back();
    m_states.pop_back();    
  }
  void push_state() {m_states.push_back(m_state);}
public:
  class base_cmd {
    INLIB_SCLASS(inlib::insh::base_cmd)
  public:
    virtual base_cmd* copy() const = 0;
    virtual void execute(const std::vector<std::string>& a_args) = 0;
    virtual const std::string& help() = 0;
    virtual void complete_command(const std::string&,std::vector<std::string>& a_names) const {a_names.clear();}
  public:
    base_cmd() {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    virtual ~base_cmd() {
#ifdef INLIB_MEM
      mem::decrement(s_class().c_str());
#endif
    }
  protected:
    base_cmd(const base_cmd&) {
#ifdef INLIB_MEM
      mem::increment(s_class().c_str());
#endif
    }
    base_cmd& operator=(const base_cmd&) {return *this;}
  };
public:
  insh(std::ostream& a_out,const std::string& a_history_file = std::string())
  :parent()
  ,m_out(a_out)
  ,m_states()
  ,m_state(a_out)
  ,m_history_file(a_history_file)
  ,m_complete_state(false)
  {
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
    init_builtins();
  }
  virtual ~insh() {
    safe_clear(m_cmds);
    safe_clear(m_builtins);
#ifdef INLIB_MEM
    mem::decrement(s_class().c_str());
#endif
  }
public:
  insh(const insh& a_from)
  :parent(a_from)
  ,m_out(a_from.m_out)
  ,m_states(a_from.m_states)
  ,m_state(a_from.m_state)
  ,m_history_file(a_from.m_history_file)
  ,m_complete_state(a_from.m_complete_state)
  {
#ifdef INLIB_MEM
    mem::increment(s_class().c_str());
#endif
    safe_clear(m_builtins);
    copy(m_builtins,a_from.m_builtins);
    safe_clear(m_cmds);
    copy(m_cmds,a_from.m_cmds);
  }
  insh& operator=(const insh& a_from){
    //parent::operator=(a_from);
    if(&a_from==this) return *this;
    safe_clear(m_builtins);
    copy(m_builtins,a_from.m_builtins);
    safe_clear(m_cmds);
    copy(m_cmds,a_from.m_cmds);
    m_states = a_from.m_states;
    m_state = a_from.m_state;
    m_history_file  = a_from.m_history_file;
    m_complete_state = a_from.m_complete_state;
    return *this;
  }
public:

  void set_v(bool a_value) {m_state.m_set_v = a_value;}
  void set_x(bool a_value) {m_state.m_set_x = a_value;}
  void set_n(bool a_value) {m_state.m_set_n = a_value;}
  void set_d(bool a_value) {m_state.m_set_d = a_value;}

  bool set_v() const {return m_state.m_set_v;}
  bool set_x() const {return m_state.m_set_x;}
  bool set_n() const {return m_state.m_set_n;}
  bool set_d() const {return m_state.m_set_d;}

  void set_history_file(const std::string& a_history) {m_history_file = a_history;}

  bool is_command(const std::string& a_name) const {return is_key(m_cmds,a_name);}
  void add_command(const std::string& a_name,base_cmd* a_cmd) {  //we take ownership of a_cmd.
    if(is_key(m_cmds,a_name)) {
      warn("insh::add_command : "+a_name+" already exists.");
      delete a_cmd;
      return;
    }
    m_cmds[a_name] = a_cmd;
  }
  void command_names(std::vector<std::string>& a_names,const std::string& a_begin = std::string(),bool a_sort = true) const { //for _help_complete.
    a_names.clear();
    if(a_begin.empty()) {
     {inlib_mforcit(std::string,base_cmd*,m_cmds,it) a_names.push_back((*it).first);}
     {inlib_mforcit(std::string,base_cmd*,m_builtins,it) a_names.push_back((*it).first);}
    } else {     
     {inlib_mforcit(std::string,base_cmd*,m_cmds,it) {
        if(is_beg((*it).first,a_begin)) a_names.push_back((*it).first);
      }}
     {inlib_mforcit(std::string,base_cmd*,m_builtins,it) {
        if(is_beg((*it).first,a_begin)) a_names.push_back((*it).first);
      }}
    }
    if(a_sort) sort::sort(a_names);
  }

  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
//  void set_to_stop() {m_state.m_to_stop = true;}
  void reset_to_stop() {m_state.m_to_stop = false;}
  //void set_return_value(const std::string& a_s) {m_state.m_backquote_return = a_s;}
  bool to_stop() const {return m_state.m_to_stop;}
  
  bool in_backquote() const {return m_state.m_in_backquote;}

  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
  void out(const char* a_s,bool a_append = false,bool a_endl = true)  {out(std::string(a_s),a_append,a_endl);}

  void outb(bool a_v,bool a_append = false,bool a_endl = true)  {
    if(m_state.m_in_backquote) {
      std::string sv;
      b2s(a_v,sv);
      if(a_append && sv.size()) {
        if(m_state.m_backquote_return.size()) m_state.m_backquote_return += " ";
        m_state.m_backquote_return += sv;
      } else {
        m_state.m_backquote_return = sv;
      }
    } else {
      m_out << (a_v?"true":"false");
      if(a_endl) m_out << std::endl; else m_out.flush();
    }
  }
/*
  template <class T>
  void out_num(const T& a_v,bool a_append = false,bool a_endl = true)  {
    if(m_state.m_in_backquote) {
      std::string sv;
      if(!num2s(a_v,sv)) {
        warn("insh::out : num2s failed.");
	return;
      }
      if(a_append && sv.size()) {
        if(m_state.m_backquote_return.size()) m_state.m_backquote_return += " ";
        m_state.m_backquote_return += sv;
      } else {
        m_state.m_backquote_return = sv;
      }
    } else {
      m_out << a_v;
      if(a_endl) m_out << std::endl; else m_out.flush();
    }
  }
*/
  void out_size_t(size_t a_v,bool a_append = false,bool a_endl = true)  {
    if(m_state.m_in_backquote) {
      std::string sv;
      if(!size_t2s(a_v,sv)) {
        warn("insh::out : size_t2s failed.");
	return;
      }
      if(a_append && sv.size()) {
        if(m_state.m_backquote_return.size()) m_state.m_backquote_return += " ";
        m_state.m_backquote_return += sv;
      } else {
        m_state.m_backquote_return = sv;
      }
    } else {
      m_out << a_v;
      if(a_endl) m_out << std::endl; else m_out.flush();
    }
  }
  
  void out(const std::vector<std::string>& a_ss,bool a_append = false,bool a_endl = true)  {
    if(m_state.m_in_backquote) {
      if(a_append) {
        inlib_vforcit(std::string,a_ss,it) {
          if(m_state.m_backquote_return.size()) m_state.m_backquote_return += " ";
          m_state.m_backquote_return += *it;
	}
      } else if(a_ss.empty()) {
        m_state.m_backquote_return.clear();
      } else {
        m_state.m_backquote_return = a_ss.front(); //or back() ?
      }
    } else if(a_ss.size()) {
      inlib_vforcit(std::string,a_ss,it) {
        if(it!=a_ss.begin()) m_out << std::endl;
        m_out << *it;
      }
      if(a_endl) m_out << std::endl; else m_out.flush();
    }
  }
  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////

  bool get_arg_uint(const std::string& a_header,const std::string& a_arg,unsigned int& a_value) {
    if(!to(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a uint.");
      return false;
    }
    return true;
  }
  bool get_arg_uint64(const std::string& a_header,const std::string& a_arg,uint64& a_value) {
    if(!to(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a uint64.");
      return false;
    }
    return true;
  }
  bool get_arg_bool(const std::string& a_header,const std::string& a_arg,bool& a_value) {
    if(!tob(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a bool.");
      return false;
    }
    return true;
  }
  bool get_arg_float(const std::string& a_header,const std::string& a_arg,float& a_value) {
    if(!to(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a float.");
      return false;
    }
    return true;
  }
  bool get_arg_double(const std::string& a_header,const std::string& a_arg,double& a_value) {
    if(!to(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a double.");
      return false;
    }
    return true;
  }
  bool get_arg_float_color(const std::string& a_header,const std::string& a_arg,float& a_value) {
    if(!to(a_arg,a_value)) {
      warn(a_header+" argument "+sout(a_arg)+" is not a float.");
      return false;
    }
    if((a_value<0)||(a_value>1)) {
      warn(a_header+" argument "+sout(a_arg)+" must be in [0,1].");
      return false;
    }
    return true;
  }

public:
  void add_env(const std::string& a_env,const std::string& a_value) {m_state.add_env(a_env,a_value);}

  void exec_line_new_state(const std::string& a_line) {  //used in view_sg_serv.
    push_state();
    m_state = state(m_out);
    _exec_line(a_line);
    pop_state();
  }

  void exec_line_reset_to_stop(const std::string& a_line) {
    m_state.m_to_stop = false;
    _exec_line(a_line);
  }
  void exec_lines_reset_to_stop(const std::vector<std::string>& a_lines) {
    m_state.m_to_stop = false;
    _exec_lines(a_lines);
  }
  bool exec_file_reset_to_stop(const std::string& a_file) {
    m_state.m_to_stop = false;
    return _exec_file(a_file);
  }

//void remove_env(const std::string& a_env) {m_state.remove_env(a_env);}

  void add_variable(const std::string& a_variable,const std::string& a_value) {m_state.add_variable(a_variable,a_value);}
  bool is_variable(const std::string& a_name) {return m_state.is_variable(a_name);}
  bool find_variable(const std::string& a_variable,std::string& a_value) const {return m_state.find_variable(a_variable,a_value);}
  void remove_variable(const std::string& a_variable) {m_state.remove_variable(a_variable);}

  void complete(std::string& a_begin,std::vector<std::string>& a_names) const {
    // If zero or more than one name is found, a_begin is not touched, else
    // if only one name is found, a_begin is replaced by its completion and a_names is cleared.
    if(a_begin.empty()) {a_names.clear();return;}
    std::vector<std::string> ws;
    words(a_begin," ",false,ws);
    if(ws.empty()) {a_names.clear();return;} //it should not happen.
    const std::string& ws0 = ws[0];
    if(ws.size()==1) {
      base_cmd* _cmd;
      if(!find(m_builtins,ws0,_cmd)) {
        if(!find(m_cmds,ws0,_cmd)) _cmd = 0;
      }      
      if(!_cmd) {
        exec_names(a_names,ws0);
        if(a_names.size()==1) {
          a_begin = a_names[0];
          a_names.clear();
        }
        return;
      }
      // ws0 is a command name, show possible ws1s :
      _cmd->complete_command(std::string(),a_names);
      if(a_names.size()==1) {
        a_begin = ws0+" "+a_names[0];
        a_names.clear();
      }
      return;      
    }
    if(ws.size()==2) {
      const std::string& ws1 = ws[1];
      base_cmd* _cmd;
      if(!find(m_builtins,ws0,_cmd)) {
        if(!find(m_cmds,ws0,_cmd)) _cmd = 0;
      }      
      if(!_cmd) {a_names.clear();return;}
      _cmd->complete_command(ws1,a_names);
      if(a_names.size()==1) {
        a_begin = ws0+" "+a_names[0];
        a_names.clear();
      }
      return;
    }
    a_names.clear();
  }
protected:
  bool is_exec(const std::string& a_string) const {
    if(m_state.is_alias(a_string)) return true;
    if(is_builtin(a_string)) return true;
    if(is_command(a_string)) return true;
    return false;
  }
public:
  void exec_names(std::vector<std::string>& a_names,const std::string& a_begin = std::string(),bool a_sort = true) const {  //used in cbk/insh.
    a_names.clear();
    if(a_begin.empty()) {
     {inlib_mforcit(std::string,base_cmd*,m_cmds,it) a_names.push_back((*it).first);}
     {inlib_mforcit(std::string,base_cmd*,m_builtins,it) a_names.push_back((*it).first);}
     {inlib_vforcit(alias_t,m_state.m_aliases,it) a_names.push_back((*it).first);}
    } else {
     {inlib_mforcit(std::string,base_cmd*,m_cmds,it) {
       if(is_beg((*it).first,a_begin)) a_names.push_back((*it).first);
      }}
     {inlib_mforcit(std::string,base_cmd*,m_builtins,it) {
       if(is_beg((*it).first,a_begin)) a_names.push_back((*it).first);
      }}
     {inlib_vforcit(alias_t,m_state.m_aliases,it) {
       if(is_beg((*it).first,a_begin)) a_names.push_back((*it).first);
      }}
    }
    if(a_sort) sort::sort(a_names);
  }
protected:
  bool is_builtin(const std::string& a_name) const {return is_key(m_builtins,a_name);}
  void add_builtin(const std::string& a_name,base_cmd* a_cmd) {  //we take ownership of a_cmd.
    if(is_key(m_builtins,a_name)) {
      warn("insh::add_builtin : "+a_name+" already exists.",false);
      delete a_cmd;
      return;
    }
    m_builtins[a_name] = a_cmd;
  }
  
  bool copy_state(const state& a_state) {
    std::vector<var_t> _vars;
   {inlib_vforcit(var_t,m_state.m_vars,it) {
      if((*it).second.m_is_env) _vars.push_back(*it);
    }}
    m_state = a_state;
   {inlib_vforcit(var_t,_vars,it) m_state.add_env((*it).first,(*it).second.m_value);}
    return true;
  }
  
  bool _assign(const std::string& a_arg,bool a_env,bool a_alias) {
    std::string::size_type pos = a_arg.find('=');
    if(pos==std::string::npos) return false;
    std::string _var = a_arg.substr(0,pos);
    if(!is_C_variable(_var)) return false;
    std::string value = a_arg.substr(pos+1,a_arg.size()-(pos+1));
    if(a_env) {
      m_state.add_env(_var,value);
    } else if(a_alias) {
      m_state.add_alias(_var,value);
    } else {
      m_state.add_variable(_var,value);
    }
    return true;
  }

  bool look_for_alias(const std::vector<sh_string>& a_words) {
    std::string first_word;
    std::vector<sh_string> _words;
   {std::string arg;
    inlib_vforcit(sh_string,a_words,it) {
      if((*it).m_type==sh_string::string_space) {
        if(arg.size()) {
          if(first_word.empty()) first_word = arg;
          arg.clear();
        }
      } else {
        arg += *it;
      }
      if(first_word.size()) _words.push_back(*it);
    }
    if(arg.size()) {
      if(first_word.empty()) first_word = arg;
      arg.clear();
    }}
    if(m_state.m_set_d) {
      m_out << "inlib::insh::look_for_alias : first_word : " << sout(first_word) << std::endl;
      m_out << "inlib::insh::look_for_alias : sh_strings : number " << _words.size() << " :" << std::endl;
      inlib_vforcit(sh_string,_words,it) m_out << " " << sout(*it) << " " << (*it).m_type << std::endl;
    }
    inlib_vforcit(alias_t,m_state.m_aliases,it) {
      if((*it).first==first_word) {
        std::string sa;
       {inlib_vforcit(sh_string,_words,itw) {
          if((*itw).m_type==sh_string::string_simple) {
            sa += "'"+*itw+"'";
          } else if((*itw).m_type==sh_string::string_double) {
            sa += "\""+*itw+"\"";
          } else { //it should remain sh_string::string_none, string_space.
            sa += *itw;
          }
        }}
        _exec_line((*it).second+" "+sa);
        return true;
      }
    }
    return false;
  }

  static bool replace_dollar_brace_variables(const state& a_state,std::string& a_string,std::string& a_error) {
    //bool rep_done = false;
    std::string::size_type dollar_brace;
    while((dollar_brace=a_string.find("${"))!=std::string::npos){
      std::string::size_type back_brace = a_string.find('}',dollar_brace+2);
      if(back_brace==std::string::npos) {
        a_error = "inlib::insh::replace_dollar_brace_variables : a } is lacking in "+sout(a_string)+".";
        return false;
      }
      // aa${bbb}cccc   12
      // 012345678901
      // dollar_brace   = 2
      // dollar_brace+2 = 4
      // back_brace     = 7
      std::string var = a_string.substr(dollar_brace+2,back_brace-(dollar_brace+2));
      if(var.empty()) {
        a_error = "inlib::replace_dollar_brace_variables : ${} : bad substitution.";
        return false;
      }
      std::string value;
      if(!a_state.find_variable(var,value)) {
        a_error = "inlib::insh::replace_dollar_brace_variables : variable "+sout(var)+" not found.";
        return false;
      } else {
        a_string = a_string.substr(0,dollar_brace)+value+a_string.substr(back_brace+1,a_string.size()-(back_brace+1));
        //rep_done = true;
      }
    }
    a_error.clear();
    return true;
  }

  static bool replace_dollar_variables(const state& a_state,std::string& a_string,std::string& a_error) {
    //bool rep_done = false;
    std::string::size_type dollar_brace;
    while((dollar_brace=a_string.find("$"))!=std::string::npos){
      std::string::size_type space_brace = a_string.find(' ',dollar_brace+1);
      std::string var;
      if(space_brace==std::string::npos) {
	if((dollar_brace+1)==a_string.size()) {
          // aa$ 3
          // dollar_brace = 2
          // dollar_brace+1 = 3
	} else {
          // aa$bbb 6
          // dollar_brace = 2
          // dollar_brace+1 = 3
          var = a_string.substr(dollar_brace+1,a_string.size()-(dollar_brace+1));
	}
      } else {
        // aa$bbb ccccc   12
        // 012345678901
        // dollar_brace   = 2
        // dollar_brace+1 = 3
        // space_brace    = 6
        var = a_string.substr(dollar_brace+1,space_brace-(dollar_brace+1));
      }
      if(var.empty()) return true;  // $ consider as a character. echo $ => print $.
      std::string value;
      if(!a_state.find_variable(var,value)) {
        a_error = "inlib::insh::replace_dollar_variables : variable "+sout(var)+" not found.";
        return false;
      } else {
        if(space_brace==std::string::npos) {
          a_string = a_string.substr(0,dollar_brace)+value;
	} else {
          a_string = a_string.substr(0,dollar_brace)+value+a_string.substr(space_brace,a_string.size()-space_brace);
	}
        //rep_done = true;
      }
    }
    a_error.clear();
    return true;
  }

public:
  void _exec_line(const std::string& a_line) {
    if(m_state.m_set_v) m_out << a_line << std::endl;

    if(m_state.m_set_d) m_out << "inlib::insh::_exec_line : begin : " << sout(a_line) << std::endl;
    
    std::string line = a_line;
    
    std::string serror;

   {std::string::size_type pos;
    if(!find_first_sharp(line,pos,serror)) {warn(serror);return;}
    if(pos!=std::string::npos) line = line.substr(0,pos);}
  
    strip(line);
    
    if(line.empty()) return;
    if(line.substr(0,1)=="#") return;
    
    if(m_state.m_set_d) m_out << "inlib::insh::_exec_line : after strip and not comment : " << sout(line) << std::endl;

    std::vector<sh_string> words;
    if(!get_strings(line,words,serror)) {warn(serror);return;}
    if(m_state.m_set_d) {
      m_out << "inlib::insh::_exec_line : sh_strings : number " << words.size() << " :" << std::endl;
      inlib_vforcit(sh_string,words,it) m_out << " " << sout(*it) << " " << (*it).m_type << std::endl;
    }

   {inlib_vforit(sh_string,words,it) {
      if( ((*it).m_type==sh_string::string_none)   ||
          ((*it).m_type==sh_string::string_double) ||
	  ((*it).m_type==sh_string::string_back)   ){
        if(!replace_dollar_brace_variables(m_state,*it,serror)) {warn(serror);return;}
        if(!replace_dollar_variables(m_state,*it,serror)) {warn(serror);return;}
      }
    }}
    if(m_state.m_set_d) {
      m_out << "inlib::insh::_exec_line : after ${} : sh_strings : number " << words.size() << " :" << std::endl;
      inlib_vforcit(sh_string,words,it) m_out << " " << sout(*it) << " " << (*it).m_type << std::endl;
    }

   {inlib_vforit(sh_string,words,it) {
      if((*it).m_type==sh_string::string_back) {
        if(m_state.m_set_d) {
           m_out << "inlib::insh::_exec_line : backquote " << sout(*it) << "." << std::endl;
        }
        bool old_in_backquote = m_state.m_in_backquote;
        std::string old_backquote_return = m_state.m_backquote_return;
        m_state.m_in_backquote = true;
        m_state.m_backquote_return.clear();
        _exec_line(*it);
        std::string _ret = m_state.m_backquote_return;
        if(m_state.m_set_d) {
           m_out << "inlib::insh::_exec_line : backquote value " << sout(_ret) << "." << std::endl;
        }
        m_state.m_in_backquote = old_in_backquote;
        m_state.m_backquote_return = old_backquote_return;
        if(m_state.m_to_stop) return;
        *it = _ret;
      }
    }}
    if(m_state.m_set_d) {
      m_out << "inlib::insh::_exec_line : after backquote : sh_strings : number " << words.size() << " :" << std::endl;
      inlib_vforcit(sh_string,words,it) m_out << " " << sout(*it) << " " << (*it).m_type << std::endl;
    }

    // build args by gathering words not separated by spaces :
    std::vector<std::string> args;
   {std::string arg;
    inlib_vforcit(sh_string,words,it) {
      if((*it).m_type==sh_string::string_space) {
        if(arg.size()) {args.push_back(arg);arg.clear();}
      } else {
        arg += *it;
      }
    }
    if(arg.size()) {args.push_back(arg);arg.clear();}}
    if(m_state.m_set_d) {
      m_out << "inlib::insh::_exec_line : args : number " << args.size() << " :" << std::endl;
      inlib_vforcit(std::string,args,it) m_out << " " << sout(*it) << std::endl;
    }

    if(args.empty()) return;

    if(_assign(args[0],false,false)) return;  //assignement has priority on alias.

    if(look_for_alias(words)) return;

    std::string cmd = args[0];
    args.erase(args.begin());

    if(m_state.m_set_d) {
      m_out << "inlib::insh::_exec_line : cmd : " << sout(cmd) << std::endl;
      m_out << "inlib::insh::_exec_line : args : number " << args.size() << " :" << std::endl;
      inlib_vforcit(std::string,args,it) m_out << " " << sout(*it) << std::endl;
    }

    //if one day we have functions, they will be executed here.

    if(m_state.m_set_x) {
      m_out << cmd;
      inlib_vforcit(std::string,args,it) m_out << " '" << *it << "'";
      m_out << std::endl;
    }

   {base_cmd* _cmd;
    if(!find(m_builtins,cmd,_cmd)) {
      if(!find(m_cmds,cmd,_cmd)) _cmd = 0;
    }      
    if(_cmd) {
      if(m_state.m_set_n) {
        if( (cmd=="set") && args.size() && (args[0]=="+n") ) _cmd->execute(args);
      } else {
        _cmd->execute(args);
      }
      return;
    }}

    // look for a file :
    if(cmd==".") {
      if(args.empty()) {
        warn("inlib::insh::_exec_line : . : one argument expected.");
	return;
      }
      std::string file = args[0];
      if(_search_file(file)) {
        args.erase(args.begin());

        std::string sc;
       {size_t2s(args.size(),sc);
        m_state.add_variable("#",sc);
        m_state.add_variable("0",file);
       {for(size_t count=0;count<args.size();count++) {
          size_t2s(count+1,sc);
          m_state.add_variable(sc,args[count]);
        }}}
	
        _source_file(file);

        m_state.remove_variable("#");
        m_state.remove_variable("0");
       {for(size_t count=0;count<args.size();count++) {
          size_t2s(count+1,sc);
          m_state.remove_variable(sc);
        }}

	return;
      }
      warn("inlib::insh::_exec_line : . : file "+sout(file)+" not found.");
      return;
    }

    if(_search_file(cmd)) {
      _exec_file_new_state(cmd,args);
      return;
    }	

    warn("inlib::insh::_exec_line : "+sout(cmd)+" not found.");
  }
  bool _search_file(std::string& a_file) {
    if(file::exists(a_file)) return true;
    std::vector<std::string> paths;
    m_state.find_paths(paths);
    inlib_vforcit(std::string,paths,it) {
      std::string path = (*it)+sep()+a_file;
      if(m_state.m_set_d) m_out << "inlib::insh::_search_file : search file : try " << sout(path) << std::endl;
      if(file::exists(path)) {
        a_file = path;
        return true;
      }
    }
    return false;
  }
  void _exec_lines(const std::vector<std::string>& a_lines) {
    inlib_vforcit(std::string,a_lines,it) {
      _exec_line(*it);
      if(m_state.m_to_stop) break;
      if(m_state.m_is_sourcing && m_state.m_to_return) break;
    }
  }
  bool _exec_file(const std::string& a_file) {
    if(!file::exists(a_file)) {    
      warn("insh::_exec_file : "+a_file+" not found.");
      return false;
    }
    std::vector<std::string> lines;    
    if(!file::read(a_file,lines)) {
      warn("insh::_exec_file : can't read "+a_file);
      return false;
    }
    _exec_lines(lines);
    return true;
  }
  void _source_file(const std::string& a_file) {
    bool old_is_sourcing = m_state.m_is_sourcing;
    bool old_to_return = m_state.m_to_return;
    m_state.m_is_sourcing = true;
    m_state.m_to_return = false;
    _exec_file(a_file);
    m_state.m_is_sourcing = old_is_sourcing;
    m_state.m_to_return = old_to_return;
  }
  void _exec_file_new_state(const std::string& a_file,const std::vector<std::string>& a_args) {
    state _state(m_out);
    push_state();
    if(copy_state(_state)) {
     {std::string sc;
      size_t2s(a_args.size(),sc);
      m_state.add_variable("#",sc);
      m_state.add_variable("0",a_file);
      for(size_t count=0;count<a_args.size();count++) {
        size_t2s(count+1,sc);
        m_state.add_variable(sc,a_args[count]);
      }}
      _exec_file(a_file);
    }
    bool to_stop = m_state.m_to_stop;
    pop_state();
    if(to_stop) m_state.m_to_stop = true;
  }
  void print_last_history(size_t a_n,bool a_all) {
    std::vector<std::string> lines;
    if(!file::read(m_history_file,lines)) {
      warn("inlib::insh::print_last_history : can't read history file "+m_history_file+".");
      return;
    }
    size_t _size = lines.size();
    if(!_size) return;
    std::string _ss;
    size_t2s(_size,_ss);
    size_t _size_size = _ss.size();
    
    size_t beg = 0;
    if(!a_all) {
      if(size_t(a_n)>_size) {
        //std::string _sn;
        //num2s(a_n,_sn);
        //warn("inlib::insh::history : "+_sn+" greater than history size "+_ss+" .");
        //return;
        beg = 0;
      } else {
        beg = _size-a_n;
      }
    }
   {std::string _si;
    for(size_t index=beg;index<_size;index++) {
      size_t2s(index+1,_si);
      justify(_si,_size_size,side_right);
      m_out << " " << _si << " " << lines[index] << std::endl;
    }}
  }
public:  
  bool append_to_history(const std::string& a_line) {
    std::vector<std::string> lines;
    if(!file::read(m_history_file,lines)) {
      warn("inlib::insh::append_to_history : can't read history file "+m_history_file+".");
      return false;
    }
    lines.push_back(a_line);
    if(!file::write(m_history_file,lines)) {
      warn("inlib::insh::append_to_history : write history file "+m_history_file+" failed.");
      return false;
    }
    return true;
  }
  bool get_history_line(size_t a_index,bool a_last,std::string& a_line) {
    std::vector<std::string> lines;
    if(!file::read(m_history_file,lines)) {
      warn("inlib::insh::get_history_line : can't read history file "+m_history_file+".");
      a_line.clear();
      return false;
    }
    size_t _size = lines.size();
    if(!_size) {a_line.clear();return false;}
    if(a_last) {
      a_line = lines[lines.size()-1];
      return true;
    }
    if((a_index<=0)||(a_index>lines.size())) {
      std::string _s;
      size_t2s(a_index,_s);
      warn("inlib::insh::get_history_line : "+_s+" not found.");
      a_line.clear();
      return false;
    }
    a_line = lines[a_index-1].c_str();
    return true;
  }    
  bool get_history_line_beg(const std::string& a_begin,std::string& a_line) {
    std::vector<std::string> lines;
    if(!file::read(m_history_file,lines)) {
      warn("inlib::insh::get_history_line_beg : can't read history file "+m_history_file+".");
      a_line.clear();
      return false;
    }
    inlib_vforcrit(std::string,lines,it) {
      if(is_beg(*it,a_begin)) {
        a_line = *it;
	return true;
      }
    }
    warn("inlib::insh::get_history_line : line starting with "+a_begin+" not found.");
    a_line.clear();
    return false;
  }

public:
  static int tab_hook(char* a_buffer,int a_size_prompt,int* a_loc,void* a_tag) {
    inlib::insh& _insh = *((inlib::insh*)a_tag);
    std::ostream& out = _insh.out();
    std::string _buffer(a_buffer);
    if(_buffer.empty() || !_insh.is_exec(_buffer)) {
      if(!_insh.m_complete_state) {
        out << '\a' << std::flush; //beep.
        _insh.m_complete_state = true;
        return *a_loc;
      }
      _insh.m_complete_state = false;
      std::vector<std::string> names;
      if(_buffer.empty()) {
        _insh.exec_names(names);
      } else {
        _insh.complete(_buffer,names);
      }
      if(names.empty()) {
        std::string _s = _buffer+" ";
        ::strcpy(a_buffer,_s.c_str());
        int i = *a_loc;
         *a_loc = i+int(_s.size());
        return i;
      }
      out << '\a' << std::flush; //beep.
      out << std::endl;
    //inlib_vforcit(std::string,names,it) out << *it << std::endl;
      _insh.unix_print(names);
      return -2;
    }
    return *a_loc;
  }

public:  //builtins :
  static const std::string& no_help() {static const std::string s_help("no help\n");return s_help;}
  static void no_complete(const insh&,const std::string&,std::vector<std::string>& a_names) {a_names.clear();}
protected:
//  void _command(const std::string& a_rest) {
//  }
  void _history(const std::vector<std::string>& a_args) {
    if(m_history_file.empty()) {
      warn("inlib::insh::_history : no history file specified.");
      return;
    }
    if(a_args.empty()) {
      print_last_history(0,true); // true = all.
      return;
    }      
    args _args(a_args);
    if(_args.is_arg("-c")) {
      file::make_empty(m_history_file);
      return;
    }
    std::string _first;
    if(!_args.first_not_hyphen(_first)) return;
    unsigned int n;
    if(!get_arg_uint("inlib::insh::_history",_first,n)) return;
    print_last_history(n,false); // n last lines.
  }
  static const std::string& _history_help() {
    static const std::string s_help("\
history: history [-c] [n]\n\
  Display the history list with line numbers.\n\
  Argument of n says to list only the last n lines.\n\
  The -c option causes the history list to be\n\
  cleared by deleting all of the entries.\n\
");
    return s_help;
  }

  void _help(const std::vector<std::string>& a_args) {
    if(a_args.empty()) return;
    const std::string& scmd = a_args[0];
    base_cmd* _cmd;
    if(!find(m_builtins,scmd,_cmd)) {
      if(!find(m_cmds,scmd,_cmd)) _cmd = 0;
    }      
    if(!_cmd) {
      warn("inlib::insh::_help : command "+sout(scmd)+" not found.");
      return;
    }
    //out_begin();
    //out(_cmd->help(),true,false);
    out(_cmd->help(),false,false);
  }
  static void _help_complete(const insh& a_holder,const std::string& a_begin,std::vector<std::string>& a_names) {a_holder.command_names(a_names,a_begin);}
  static const std::string& _help_help() {
    static const std::string s_help("\
help: help [command]\n\
  Display informations about a command.\n\
");
    return s_help;
  }

  void _return(const std::vector<std::string>& /*a_args*/) {
    if(!m_state.m_is_sourcing) {
      warn("inlib::insh::_return : can only return when sourcing.");
      return;
    }
    m_state.m_to_return = true;
  }
  static const std::string& _return_help() {
    static const std::string s_help("\
return: return\n\
  Causes a sourced file to exit.\n\
");
    return s_help;
  }

  static const std::string& _exit_help() {
    static const std::string s_help("\
exit: exit\n\
  Causes a not sourced file to exit.\n\
  In interactives mode, it stops the shell.\n\
");
    return s_help;
  }

  void _alias(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      out_begin();
      inlib_vforcit(alias_t,m_state.m_aliases,it) out("alias "+(*it).first+"='"+(*it).second+"'",true);
      return;
    }
    if(a_args.size()!=1) {
      warn("inlib::insh::_alias : one argument expected.");
      return;
    }
    const std::string& _arg = a_args[0];
    if(_arg.find('=')==std::string::npos) {
      std::string value;
      if(!m_state.find_alias(_arg,value)) {
        warn("inlib::insh::_alias : "+sout(_arg)+" not found.");
        return;
      }
      out("alias "+_arg+"='"+value+"'");
      return;
    }
    _assign(_arg,false,true);
  }

  void _let(const std::vector<std::string>& a_args) {
    if(a_args.size()!=1) {
      warn("inlib::insh::_let : one argument expected.");
      return;
    }
    if(!is_command("calc")) {
      warn("inlib::insh::_let : calc is not a command.");
      return;
    }
    const std::string& _first = a_args[0];
    std::string::size_type pos = _first.find('=');
    if(pos==std::string::npos) {
      warn("inlib::insh::_let : no '=' found in "+sout(_first)+".");
      return;
    }
    std::string _var = _first.substr(0,pos);
    if(!is_C_variable(_var)) {
      warn("inlib::insh::_let : "+sout(_var)+" has not a variable syntax.");
      return;
    }
    std::string rest = _first.substr(pos+1,_first.size()-(pos+1));
    bool old_back = m_state.m_in_backquote;
    m_state.m_in_backquote = true;
    _exec_line("calc "+rest);
    m_state.m_in_backquote = old_back;
    if(!m_state.m_to_stop) m_state.add_variable(_var,m_state.m_backquote_return);
  }

  void _echo(const std::vector<std::string>& a_args) {
    std::vector<std::string> args(a_args);
    bool opt_n = false;
    if(args.size() && (args[0]=="-n")) {
      opt_n = true;
      args.erase(args.begin());
    }
    out_begin();
    std::string sa;
    conc(args," ",sa);
    out(sa,true,opt_n?false:true);
  }
  static const std::string& _echo_help() {
    static const std::string s_help("\
echo: [-n] [arg ...]\n\
  Output the args.\n\
  If -n is specified, the trailing newline is suppressed.\n\
");
    return s_help;
  }
  
  void _printenv(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      out_begin();
      inlib_vforcit(var_t,m_state.m_vars,it) {
        if((*it).second.m_is_env) out((*it).first+"="+(*it).second.m_value,true);
      }
      return;
    }
    std::string value;
    if(!m_state.find_env(a_args[0],value)) {
      warn("inlib::insh::_printenv : "+sout(a_args[0])+" is not an env.");
      return;
    }
    out(value);
  }
  
  void _compgen(const std::vector<std::string>& a_args) {
    if(a_args.empty()) return;
    bool opt_c = false;
    bool opt_b = false;
    bool opt_a = false;
    bool opt_e = false;
    const std::string& _opt = a_args[0];
         if(_opt=="-c") opt_c = true;
    else if(_opt=="-b") opt_b = true;
    else if(_opt=="-a") opt_a = true;
    else if(_opt=="-e") opt_e = true;
    else {
      warn("inlib::insh::_compgen : option "+sout(_opt)+" unknow.");
      return;
    }
    out_begin();
    if(opt_c || opt_a) {inlib_vforcit(alias_t,m_state.m_aliases,it) out((*it).first,true);}
    if(opt_c || opt_b) {inlib_mforcit(std::string,base_cmd*,m_builtins,it) out((*it).first,true);}
    if(opt_c) {inlib_mforcit(std::string,base_cmd*,m_cmds,it) out((*it).first,true);}
    if(opt_e) {inlib_vforcit(var_t,m_state.m_vars,it) if((*it).second.m_is_env) out((*it).first,true);}
  }
  static const std::string& _compgen_help() {
    static const std::string s_help("\
compgen: compgen [-cbae]\n\
  -c list all aliases, builtins and other commands.\n\
  -b list all builtins.\n\
  -a list all aliases.\n\
  -e list all environment variables.\n\
");
    return s_help;
  }

  void _type(const std::vector<std::string>& a_args) {
    if(a_args.empty()) return;
    std::vector<std::string>::const_iterator it_begin = a_args.begin();
    bool opt_t = false;
    if(a_args[0][0]=='-') {
      if(a_args[0]=="-t") {
        opt_t = true;
        it_begin++;
      } else {
        warn("inlib::insh::_type : "+sout(a_args[0])+" is not an option.");
        return;
      }
    }
    out_begin();
    inlib_vforcit_beg(std::string,a_args,it_begin,it) {
      if(m_state.is_alias(*it)) {
        if(opt_t) {
          out("alias",true);
        } else {
          out((*it)+" is an alias",true);
        }
        continue;
      }
     {base_cmd* _cmd;
      if(find(m_builtins,*it,_cmd)) {
        if(opt_t) {
          out("builtin",true);
        } else {
          out((*it)+" is a builtin",true);
        }
        continue;
      }}
     {base_cmd* _cmd;
      if(find(m_cmds,*it,_cmd)) {
        if(opt_t) {
          out("compiled",true);
        } else {
          out((*it)+" is compiled",true);
        }
        continue;
      }}
     {std::string file = *it;
      if(_search_file(file)) {
        if(opt_t) {
          out("file",true);
        } else {
          out((*it)+" is a file",true);
        }
        continue;
      }}
      out("unfound",true);
    }
  }
  static const std::string& _type_help() {
    static const std::string s_help("\
type: type [-t] name [name ...]\n\
  For each name, indicate how it would be interpreted if used as a command name.\n\
\n\
  If the -t option is used, it outputs a single word which is one of\n\
  [alias, builtin, compiled, file, unfound] if the name is an alias, shell builtin,\n\
  other compiled command, a file or is unfound.\n\
");
    return s_help;
  }

  void _exit(const std::vector<std::string>&) {m_state.m_to_stop = true;}
  
  void _date(const std::vector<std::string>&) {
    std::string sdate;
    time2s(sdate);
    out(sdate);
  }
  static const std::string& _date_help() {
    static const std::string s_help("\
date: date\n\
  Print date and time.\n\
");
    return s_help;
  }
  
  void _time(const std::vector<std::string>& a_args) {
    std::string sa;
    conc(a_args," ",sa);
    atime _start = atime::now();
    _exec_line(sa);
    atime _end = atime::elapsed(_start);
    
    sa.clear();
    numas(_end.seconds(),sa);
    sa += " secs ";
    numas(_end.micro_seconds(),sa);
    sa += " micro_secs";
    out(sa);
  }
  static const std::string& _time_help() {
    static const std::string s_help("\
time: time command\n\
  Execute command and print the real time spent executing it.\n\
");
    return s_help;
  }

  void _unset(const std::vector<std::string>& a_args) {
    if(a_args.empty()) return;
    if(!is_C_variable(a_args[0])) {
      warn("inlib::insh::_unset : "+sout(a_args[0])+" has not a variable syntax.");
      return;
    }
    m_state.remove_variable(a_args[0]);
  }
  void _unalias(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      warn("inlib::insh::_unalias : one argument expected.");
      return;
    }
    if(!is_C_variable(a_args[0])) {
      warn("inlib::insh::_unalias : "+sout(a_args[0])+" has not a variable syntax.");
      return;
    }
    m_state.remove_alias(a_args[0]);
  }
  void _export(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      out_begin();
      inlib_vforcit(var_t,m_state.m_vars,it) {if((*it).second.m_is_env) out("export "+(*it).first+"=\""+(*it).second.m_value+"\"",true);}
      return;
    }
    if(a_args.size()!=1) {
      warn("inlib::insh::_export : one argument expected.");
      return;
    }
    const std::string& _arg = a_args[0];
    if(_arg.find('=')==std::string::npos) {
      if(!is_C_variable(_arg)) {
        warn("inlib::insh::_export : "+sout(_arg)+" has not a variable syntax.");
        return;
      }
      if(!m_state.set_as_env(_arg)) {
        warn("inlib::insh::_export : "+sout(_arg)+" is not a variable.");
        return;
      }
      return;
    }
    _assign(_arg,true,false);
  }

  void _set(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      out_begin();
      inlib_vforcit(var_t,m_state.m_vars,it) {
        if((*it).second.m_value.find(' ')!=std::string::npos) {
          out((*it).first+"='"+(*it).second.m_value+"'",true);
        } else {
          out((*it).first+"="+(*it).second.m_value,true);
	}
      }
      return;
    }
    const std::string& _opt = a_args[0];
    if(_opt=="-v") {m_state.m_set_v = true;return;}
    if(_opt=="+v") {m_state.m_set_v = false;return;}
    if(_opt=="-x") {m_state.m_set_x = true;return;}
    if(_opt=="+x") {m_state.m_set_x = false;return;}
    if(_opt=="-n") {m_state.m_set_n = true;return;}
    if(_opt=="+n") {m_state.m_set_n = false;return;}
    if(_opt=="-d") {m_state.m_set_d = true;return;}
    if(_opt=="+d") {m_state.m_set_d = false;return;}
    warn("inlib::insh::_set : option "+sout(_opt)+" unknow.");
  }
  void _pwd(const std::vector<std::string>&) {
    std::string _pwd;
    if(!dir::pwd(_pwd)) {
      warn("inlib::insh::_pwd : can't get pwd.");
      return;
    }
    out(_pwd);
  }
  static const std::string& _pwd_help() {
    static const std::string s_help("\
pwd: pwd\n\
    Print the current working directory.\n\
");
    return s_help;
  }

  void _cd(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      std::string home;
      if(!dir::home(home)) {
        warn("inlib::insh::_cd : can't get home dir.");
        return;
      }
      if(!dir::cd(home)) {
        warn("inlib::insh::_cd : cd(home) failed..");
        return;
      }
      return;
    }
    if(!dir::cd(a_args[0])) {
      warn("inlib::insh::_cd : cd("+a_args[0]+") failed..");
      return;
    }
  }
  static const std::string& _cd_help() {
    static const std::string s_help("\
cd: cd [path]\n\
  Change the current directory to path. Without argument it goes in ${HOME}\n\
  on UNIXes (including CYGWIN) and ${USERPROFILE} on Windows from a DOS prompt.\n\
");
    return s_help;
  }

  void _cp(const std::vector<std::string>& a_args) {
    if(a_args.size()!=2) {
      warn("inlib::insh::_cp : two arguments expected.");
      return;
    }
    const std::string& from = a_args[0];
    std::string to = a_args[1];
    if(to==".") base_name(from,to);
    if(!file::copy_bytes(from,to)) {
      warn("inlib::insh::_cp : file::copy_bytes("+sout(from)+","+sout(to)+") failed.");
      return;
    }
  }

  static const std::string& _cp_help() {
    static const std::string s_help("\
cp: cp source target\n\
  Copy the contents of source file in the target file.\n\
  If target is ., a file with name being the source base name will be created\n\
  in the current directory.\n\
");
    return s_help;
  }

  void _rm(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      warn("inlib::insh::_rm : one arguments expected.");
      return;
    }
    args _args(a_args);
    std::string _path;
    if(!_args.first_not_hyphen(_path)) return;
    if(!file::exists(_path)) {
      warn("inlib::insh::_rm : file "+sout(_path)+" does not exist.");
      return;
    }
    if(::remove(_path.c_str())) {
      warn("inlib::insh::_rm : ::remove("+sout(_path)+") failed.");
      return;
    }
  }
  static const std::string& _rm_help() {
    static const std::string s_help("\
rm: rm path\n\
  Remove the file specified by path.\n\
");
    return s_help;
  }

  void _mkdir(const std::vector<std::string>& a_args) {
    if(a_args.empty()) {
      warn("inlib::insh::_mkdir : one arguments expected.");
      return;
    }
    args _args(a_args);
    std::string _path;
    if(!_args.first_not_hyphen(_path)) return;
    if(!has_dir(_path)) {
      if(!dir::mkdir(_path)) warn("inlib::insh::_mkdir : can't create directory "+sout(_path)+".");
      return;
    }
    if(inlib::dir::is_a(_path)) return;
    if(!_args.is_arg("-p")) {
      warn("inlib::insh::_mkdir : use -p to create a chain of directories.");
      return;
    }
    if(!inlib::mkdirs(m_out,_path)) {
      warn("inlib::insh::_mkdir : can't create directory "+sout(_path)+".");
    }
  }
  static const std::string& _mkdir_help() {
    static const std::string s_help("\
mkdir: mkdir [-p] name\n\
  Create directory name.\n\
  -p permits to create intermediate directories if needed.\n\
  Example:\n\
    mkdir my_dir\n\
    mkdir -p dir_0/dir_1/my_dir\n\
");
    return s_help;
  }

  void _basename(const std::vector<std::string>& a_args) {
    if(a_args.size()!=1) {
      warn("inlib::insh::_basename : one arguments expected.");
      return;
    }
    std::string name;
    base_name(a_args[0],name);
    out(name);
  }
  static const std::string& _basename_help() {
    static const std::string s_help("\
basename: basename path\n\
  Return the file name portion of a path.\n\
  Example:\n\
    basename /a/b/c.d  # return c.d\n\
");
    return s_help;
  }

  void _dirname(const std::vector<std::string>& a_args) {
    if(a_args.size()!=1) {
      warn("inlib::insh::_dirname : one arguments expected.");
      return;
    }
    std::string p,n,s;
    path_name_suffix(a_args[0],p,n,s);
    out(p);
  }
  static const std::string& _dirname_help() {
    static const std::string s_help("\
dirname: dirname path\n\
  Return the directory portion of a path.\n\
  Example:\n\
    dirname /a/b/c.d  # return /a/b\n\
");
    return s_help;
  }

  void _suffix(const std::vector<std::string>& a_args) {
    if(a_args.size()!=1) {
      warn("inlib::insh::_suffix : one arguments expected.");
      return;
    }
    std::string p,n,s;
    path_name_suffix(a_args[0],p,n,s);
    out(s);
  }
  static const std::string& _suffix_help() {
    static const std::string s_help("\
suffix: suffix path\n\
  Return the suffix portion of a path.\n\
  Example:\n\
    suffix /a/b/c.d  # return d\n\
");
    return s_help;
  }

public:

#define INLIB_INSH_VOID_ARGS_CMD(a__holder)\
  class a__holder##_void_args_cmd : public inlib::insh::base_cmd {\
    typedef inlib::insh::base_cmd parent;\
  protected:\
    typedef void(a__holder::*method)(const std::vector<std::string>&);\
    typedef const std::string&(*help_func)();\
    typedef void(*complete_func)(const a__holder&,const std::string&,std::vector<std::string>&);\
  public:\
    virtual base_cmd* copy() const {return new a__holder##_void_args_cmd(*this);}\
    virtual void execute(const std::vector<std::string>& a_args) {(m_holder.*m_exec)(a_args);}\
    virtual const std::string& help() {return m_help();}\
    virtual void complete_command(const std::string& a_begin,std::vector<std::string>& a_names) const {m_complete(m_holder,a_begin,a_names);}\
  public:\
    a__holder##_void_args_cmd(a__holder& a_holder,method a_exec,help_func a_help,complete_func a_complete = no_complete)\
    :m_holder(a_holder),m_exec(a_exec),m_help(a_help),m_complete(a_complete){}\
    virtual ~a__holder##_void_args_cmd() {}\
  public:\
    a__holder##_void_args_cmd(const a__holder##_void_args_cmd& a_from)\
    :parent(a_from),m_holder(a_from.m_holder),m_exec(a_from.m_exec),m_help(a_from.m_help),m_complete(a_from.m_complete)\
    {}\
    a__holder##_void_args_cmd& operator=(const a__holder##_void_args_cmd& a_from) {\
      parent::operator=(a_from);\
      m_exec = a_from.m_exec;\
      m_help = a_from.m_help;\
      m_complete = a_from.m_complete;\
      return *this;\
    }\
  protected:\
    static void no_complete(const a__holder&,const std::string&,std::vector<std::string>& a_names) {a_names.clear();}\
  protected:\
    a__holder& m_holder;\
    method m_exec;\
    help_func m_help;\
    complete_func m_complete;\
  };

#define INLIB_INSH_BOOL_VOID_CMD(a__holder)\
  class a__holder##_bool_void_cmd : public inlib::insh::base_cmd {\
    typedef inlib::insh::base_cmd parent;\
  protected:\
    typedef bool(a__holder::*method)();\
    typedef const std::string&(*help_func)();\
  public:\
    virtual base_cmd* copy() const {return new a__holder##_bool_void_cmd(*this);}\
    virtual void execute(const std::vector<std::string>&) {(m_holder.*m_exec)();}\
    virtual const std::string& help() {return m_help();}\
  public:\
    a__holder##_bool_void_cmd(a__holder& a_holder,method a_exec,help_func a_help)\
    :m_holder(a_holder),m_exec(a_exec),m_help(a_help){}\
    virtual ~a__holder##_bool_void_cmd() {}\
  public:\
    a__holder##_bool_void_cmd(const a__holder##_bool_void_cmd& a_from)\
    :parent(a_from),m_holder(a_from.m_holder),m_exec(a_from.m_exec),m_help(a_from.m_help)\
    {}\
    a__holder##_bool_void_cmd& operator=(const a__holder##_bool_void_cmd& a_from) {\
      parent::operator=(a_from);\
      m_exec = a_from.m_exec;\
      m_help = a_from.m_help;\
      return *this;\
    }\
  protected:\
    a__holder& m_holder;\
    method m_exec;\
    help_func m_help;\
  };

#define INLIB_INSH_VOID_VOID_CMD(a__holder)\
  class a__holder##_void_void_cmd : public inlib::insh::base_cmd {\
    typedef inlib::insh::base_cmd parent;\
  protected:\
    typedef void(a__holder::*method)();\
    typedef const std::string&(*help_func)();\
  public:\
    virtual base_cmd* copy() const {return new a__holder##_void_void_cmd(*this);}\
    virtual void execute(const std::vector<std::string>&) {(m_holder.*m_exec)();}\
    virtual const std::string& help() {return m_help();}\
  public:\
    a__holder##_void_void_cmd(a__holder& a_holder,method a_exec,help_func a_help)\
    :m_holder(a_holder),m_exec(a_exec),m_help(a_help){}\
    virtual ~a__holder##_void_void_cmd() {}\
  public:\
    a__holder##_void_void_cmd(const a__holder##_void_void_cmd& a_from)\
    :parent(a_from),m_holder(a_from.m_holder),m_exec(a_from.m_exec),m_help(a_from.m_help)\
    {}\
    a__holder##_void_void_cmd& operator=(const a__holder##_void_void_cmd& a_from) {\
      parent::operator=(a_from);\
      m_exec = a_from.m_exec;\
      m_help = a_from.m_help;\
      return *this;\
    }\
  protected:\
    a__holder& m_holder;\
    method m_exec;\
    help_func m_help;\
  };

  INLIB_INSH_VOID_ARGS_CMD(insh)

#define INLIB_INSH_ADD_VOID_ARGS_BUILTIN(a__name,a__method,a__help,a__complete)\
   add_builtin(#a__name,new insh_void_args_cmd(*this,&insh::a__method,a__help,a__complete));

protected:
  void init_builtins() {
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(help,_help,_help_help,_help_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(return,_return,_return_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(echo,_echo,_echo_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(type,_type,_type_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(exit,_exit,_exit_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(history,_history,_history_help,no_complete)

    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(printenv,_printenv,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(date,_date,_date_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(compgen,_compgen,_compgen_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(unset,_unset,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(unalias,_unalias,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(export,_export,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(set,_set,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(let,_let,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(alias,_alias,no_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(time,_time,_time_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(pwd,_pwd,_pwd_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(cd,_cd,_cd_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(cp,_cp,_cp_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(mkdir,_mkdir,_mkdir_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(rm,_rm,_rm_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(basename,_basename,_basename_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(dirname,_dirname,_dirname_help,no_complete)
    INLIB_INSH_ADD_VOID_ARGS_BUILTIN(suffix,_suffix,_suffix_help,no_complete)

  }

#undef INLIB_INSH_ADD_VOID_ARGS_BUILTIN

protected:
  std::ostream& m_out;
  std::map<std::string,base_cmd*> m_builtins;
  std::map<std::string,base_cmd*> m_cmds;
  std::vector<state> m_states;
  state m_state;
  std::string m_history_file;
public:
  bool m_complete_state;
};

#define INLIB_INSH_CLASS_CMD_COMPLETE(a__holder,a__name,a__exec,a__help,a__complete) \
  class cmd_##a__name : public inlib::insh::base_cmd {\
    typedef inlib::insh::base_cmd parent;\
  public:\
    virtual base_cmd* copy() const {return new cmd_##a__name(*this);}\
    virtual void execute(const std::vector<std::string>& a_args) {a__exec;(void)a_args;}\
    virtual const std::string& help() {return a__help;}\
    virtual void complete_command(const std::string& a_begin,std::vector<std::string>& a_names) const {a__complete(m_holder,a_begin,a_names);}\
  public:\
    cmd_##a__name(a__holder& a_holder):m_holder(a_holder) {}\
    virtual ~cmd_##a__name() {}\
  public:\
    cmd_##a__name(const cmd_##a__name& a_from):parent(a_from),m_holder(a_from.m_holder) {}\
    cmd_##a__name& operator=(const cmd_##a__name& a_from) {parent::operator=(a_from);return *this;}\
  protected:\
    static void no_complete(const a__holder&,const std::string&,std::vector<std::string>& a_names) {a_names.clear();}\
  protected:\
    a__holder& m_holder;\
  };

#define INLIB_INSH_CLASS_CMD(a__holder,a__name,a__exec,a__help) \
  INLIB_INSH_CLASS_CMD_COMPLETE(a__holder,a__name,a__exec,a__help,no_complete)

#define INLIB_INSH_ADD_CMD(a__insh,a__holder,a__name)\
    (a__insh).add_command(#a__name,new cmd_##a__name(a__holder));

}

#endif
