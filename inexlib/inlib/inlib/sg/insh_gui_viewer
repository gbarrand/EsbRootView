// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_insh_gui_viewer
#define inlib_sg_insh_gui_viewer

#include "insh_node_to_bsg"
#include "../insh_ls"
#include "../insh_console" //windows.h

namespace inlib {
namespace sg {

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline return_action action_insh_source_script(gui_viewer& a_gv,const std::string& a_script) {
  std::vector<std::string> lines;
  get_lines(a_script,lines);
  a_gv.insh().exec_lines_reset_to_stop(lines);
  return sg::return_to_render;
}

inline void add_item_insh(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,const std::string& a_script) {
  add_item(a_gv,a_widget,a_label,action_insh_source_script,a_script);
}
inline void add_image_item_insh(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item(a_gv,a_widget,a_label,a_img_file,action_insh_source_script,a_script);
}

inline void add_white_item_insh(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_script) {
  add_image_item_insh(a_gv,a_widget,a_label,s_white_jpg(),a_script);
}

inline void add_image_item_insh_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_before(a_gv,a_widget,a_before,a_label,a_img_file,action_insh_source_script,a_script);
}

inline void add_image_item_insh_after(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_after(a_gv,a_widget,a_before,a_label,a_img_file,action_insh_source_script,a_script);
}
inline void add_image_item_insh_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,const std::string& a_script) {
  add_image_item_at_top(a_gv,a_widget,a_label,a_img_file,action_insh_source_script,a_script);
}


inline void create_main_button_insh(gui_viewer& a_gv,
                                    float a_wcw,float a_wch,float a_wb,float a_hb,float a_roffset,
                                    unsigned int a_col,unsigned int a_row,
                                    const std::string& a_label,const std::string& a_img_label,const std::string& a_img,
                                    const std::string& a_script) {
  create_main_button(a_gv.out(),a_gv.res_dir(),a_gv.m_params,a_gv.image_readers(),a_gv.ttf(),
                     a_gv.camenu_sep(),a_wcw,a_wch,a_wb,a_hb,a_roffset,a_col,a_row,
                     a_label,a_img_label,a_img,
                     new gv_data_cbk<std::string>(a_gv,action_insh_source_script,a_script));
}

inline void create_main_button_insh(gui_viewer& a_gv,
                                    float a_wcw,float a_wch,float a_wb,float a_hb,float a_roffset,
                                    unsigned int a_col,unsigned int a_row,
                                    image_button& a_img_button,text_button& a_button,
                                    const std::string& a_label,const std::string& a_img,
                                    const std::string& a_script) {
  create_main_button(a_gv.out(),a_gv.res_dir(),a_gv.m_params,a_gv.image_readers(),
                     a_gv.camenu_sep(),a_wcw,a_wch,a_wb,a_hb,a_roffset,a_col,a_row,
                     a_img_button,a_button,a_label,a_img,
                     new gv_data_cbk<std::string>(a_gv,action_insh_source_script,a_script));
}

inline void create_main_button_insh(gui_viewer& a_gv,
                                    float a_wcw,float a_wch,float a_wb,float a_hb,float a_roffset,
                                    unsigned int a_col,unsigned int a_row,
                                    const std::string& a_label,
				    text_button& a_button,
                                    const std::string& a_script) {
  create_main_button(a_gv.m_params,a_gv.camenu_sep(),a_wcw,a_wch,a_wb,a_hb,a_roffset,a_col,a_row,
                     a_label,a_button,
                     new gv_data_cbk<std::string>(a_gv,action_insh_source_script,a_script));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline void gui_push_list_insh(gui_viewer& a_gv,const std::vector<std::string>& a_args){
  if(a_args.empty()) {
    a_gv.map_warn_empty();
    return;
  }
  size_t nitem = a_args.size()/2;
  if(nitem*2!=a_args.size()) {
    a_gv.map_warn("even number of arguments expected.");
    return;
  }
  list* _list = new list(a_gv.ttf());
  a_gv.set_style(*_list);
  for(size_t index=0;index<nitem;index++) {
    add_white_item_insh(a_gv,*_list,a_args[2*index+0],a_args[2*index+1]);
  }
  a_gv.push_list(_list);
}

inline void insh_window_to_png(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  a_gv.hide_popup();
  a_gv.hide_main_menu();
  a_gv.hide_meta_zone();
  args _args(a_args);
  if(_args.is_arg("-hide_camera_menu")) a_gv.hide_camera_menu();
  unsigned int bpp;
  _args.find("-bpp",bpp,a_gv.produce_out_bpp());
  std::string path;
  if(_args.first_not_hyphen(path)) a_gv.set_produce_out_file(path);
  a_gv.set_produce_out_png(true);
  a_gv.set_produce_out_bpp(bpp);
  a_gv.win_render();  //it should trigger after_render().
}

inline const std::string& insh_window_to_png_help() {
  static const std::string s_help("\
window_to_png: window_to_png [-hide_camera_menu] [-bpp] [path]\n\
  Produce a png file from the displayed window contents.\n\
  If no path is given, a out.png file is produced in the output directory of the application.\n\
  -hide_camera_menu permits to hide the camera menu panel before writing.\n\
  -bpp permits to choose to produce three or four bytes per pixel (rgb or rgba).\n\
  It is four by default. It permits to save transparency/blending in the png.\n\
  Example:\n\
    window_to_png -bpp=3 out.png  # to produce an out.png in the current directory\n\
  See also:\n\
    app_out_dir\n\
");
  return s_help;
}

inline void insh_window_to_jpeg(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  a_gv.hide_popup();
  a_gv.hide_main_menu();
  a_gv.hide_meta_zone();
  args _args(a_args);
  if(_args.is_arg("-hide_camera_menu")) a_gv.hide_camera_menu();
  std::string path;
  if(_args.first_not_hyphen(path)) a_gv.set_produce_out_file(path);
  a_gv.set_produce_out_jpeg(true);
  a_gv.win_render();  //it should trigger after_render().
}

inline const std::string& insh_window_to_jpeg_help() {
  static const std::string s_help("\
window_to_jpeg: window_to_jpeg [-hide_camera_menu] [path]\n\
  Produce a jpeg file from the displayed window contents.\n\
  If no path is given, a out.jpeg file is produced in the output directory of the application.\n\
  -hide_camera_menu permits to hide the camera menu panel before writing.\n\
  Note that no alpha channel is written in the jpeg, if you want it, use the window_to_png command.\n\
  Example:\n\
    window_to_jpeg out.jpeg  # to produce an out.jpeg in the current directory\n\
  See also:\n\
    app_out_dir\n\
    window_to_png\n\
");
  return s_help;
}

inline void insh_exec_main_menu_item(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if(a_args.empty()) {
    a_gv.insh().warn("inlib::sg::insh_exec_main_menu_item : one argument expected.");
    return;
  }
  if(!a_gv.find_exec_menu_item(a_args[0])) {
    a_gv.insh().warn("inlib::sg::insh_exec_main_menu_item : menu item "+sout(a_args[0])+" not found. Stop.");
    return;
  }
}

inline const std::string& insh_exec_main_menu_item_help() {
  static const std::string s_help("\
gui_exec_main_menu_item: gui_exec_main_menu_item menu_item_label\n\
  Given its label, find a menu item in the\n\
  current main menu and execute its callback.\n\
  Example:\n\
    gui_exec_main_menu_item exit\n\
");
  return s_help;
}

inline void insh_scene_set_clear_color(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_scene_set_clear_color :");
  if(a_args.size()==1) {
    inlib::colorf _value;
    if(!inlib::sg::find_color(a_gv.styles().cmaps(),a_args[0],_value)) {
      a_gv.insh().warn(s_header+" "+sout(a_args[0])+" is not a known color.");
      return;
    }
    a_gv.set_scene_clear_color(_value);
    return;
  }
  if(a_args.size()==3) {
    float r;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[0],r)) return;
    float g;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[1],g)) return;
    float b;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[2],b)) return;
    a_gv.set_scene_clear_color(r,g,b,1);
    return;
  }
  if(a_args.size()==4) {
    float r;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[0],r)) return;
    float g;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[1],g)) return;
    float b;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[2],b)) return;
    float a;
    if(!a_gv.insh().get_arg_float_color(s_header,a_args[3],a)) return;
    a_gv.set_scene_clear_color(r,g,b,a);
    return;
  }
  a_gv.insh().warn(s_header+" one, three or four arguments expected");
}

inline const std::string& insh_scene_set_clear_color_help() {
  static const std::string s_help("\
scene_set_clear_color: scene_set_clear_color [color name] [colormap/color name] [#rrggbb] [r g b] [r g b a]\n\
  Set the color of the background of the scene.\n\
  It can be given by a common color name in the default colormap,\n\
  by giving the name of a color in a known colormap, by giving an hexa encoding or by giving\n\
  the three or four r,g,b,a (in [0,1]) of the color.\n\
  See style_print_colormaps to print the known colormaps with their colors.\n\
  Example:\n\
    scene_set_clear_color lightgrey\n\
    scene_set_clear_color ROOT/kMagenta+3\n\
    scene_set_clear_color '#FFFF00'\n\
    scene_set_clear_color 0.2 0.1 0.2\n\
");
  return s_help;
}

inline void insh_scene_bounding_box(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_scene_bounding_box :");
  bbox_action action(a_gv.out());
  a_gv.scene().bbox(action);
  if(!action.end()) {
    a_gv.insh().warn(s_header+" bbox_action.end() failed.");
    return;
  }
  const box3f& _box = action.box();
  if(_box.is_empty()) {
    a_gv.insh().out("empty");
    return;
  }
  vec3f center;
  if(!_box.center(center)) {}
  float dx,dy,dz;
  if(!_box.get_size(dx,dy,dz)) {}

  std::vector<std::string> ss;
 {std::string _s;
  numas(center.x(),_s);
  _s += " ";
  numas(center.y(),_s);
  _s += " ";
  numas(center.z(),_s);
  ss.push_back(_s);}

 {std::string _s;
  numas(dx,_s);
  _s += " ";
  numas(dy,_s);
  _s += " ";
  numas(dz,_s);
  ss.push_back(_s);}

  a_gv.insh().out_begin();
  a_gv.insh().out(ss);
}

inline const std::string& insh_scene_bounding_box_help() {
  static const std::string s_help("\
scene_bounding_box: scene_bounding_box\n\
  Print the center and size of the scene bounding box.\n\
  Example:\n\
    scene_bounding_box\n\
");
  return s_help;
}

inline void insh_scene_remove_nodes(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_scene_remove_nodes :");
  args _args(a_args);
  std::string sclass;
  if(_args.find("-class",sclass)) {
    search_action sa(a_gv.out());
    const paths_t& paths = find_paths(sa,a_gv.scene(),sclass);
    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        a_gv.insh().warn(s_header+" node parent group not found.");
      } else {
        node* _node = p.size()?p[p.size()-1]:0;
        if(!_node) {
          a_gv.insh().warn(s_header+" node path with bad tail.");
        } else {
          if(!grp->remove(_node)) {
            a_gv.insh().warn(s_header+" remove in group failed");
            return;
          }
          //::printf("debug : delete node of class %s\n",sclass.c_str());
          delete _node;
        }
      }
    }
    return;
  }
}

inline const std::string& insh_scene_remove_nodes_help() {
  static const std::string s_help("\
scene_remove_nodes: scene_remove_nodes [-class]\n\
  If -class=string, remove nodes of the given class name in the scene.\n\
  Example:\n\
    scene_remove_nodes -class=inlib::sg::cube\n\
");
  return s_help;
}

inline void insh_style_print_colormaps(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_style_print_colormaps :");
// first round trip to get item string sizes :
  size_t sindex_size = 0;
  size_t sname_size = 0;
//size_t scolor_size = 0;
  std::string _s;
 {inlib_mforcit(std::string,style_colormap,a_gv.styles().cmaps(),it) {
    inlib_mforcit(unsigned int,style_color,(*it).second,itc) {
      unsigned int index = (*itc).first;
      num2s(index,_s);
      sindex_size = mx(sindex_size,_s.size());

      const std::string& name = (*itc).second.first;
      sname_size = mx(sname_size,name.size());
    //const colorf& _color = (*itc).second.second;
    //_s .clear();
    //numas(_color.r(),_s);
    //_s += " ";
    //numas(_color.g(),_s);
    //_s += " ";
    //numas(_color.b(),_s);
    //_s += " ";
    //numas(_color.a(),_s);
    //scolor_size = mx(scolor_size,_s.size());
    }
  }}
  // print :
  a_gv.insh().out_begin();
 {inlib_mforcit(std::string,style_colormap,a_gv.styles().cmaps(),it) {
    a_gv.insh().out((*it).first+" :",true);
    inlib_mforcit(unsigned int,style_color,(*it).second,itc) {
      unsigned int index = (*itc).first;
      num2s(index,_s);
      justify(_s,sindex_size,side_left);
      a_gv.insh().out("  "+_s,true,false);

      std::string name = (*itc).second.first;
      justify(name,sname_size,side_left);
      a_gv.insh().out(" "+name,true,false);

      const colorf& _color = (*itc).second.second;
      _s .clear();
      numas(_color.r(),_s);
      _s += " ";
      numas(_color.g(),_s);
      _s += " ";
      numas(_color.b(),_s);
      _s += " ";
      numas(_color.a(),_s);
      a_gv.insh().out(" "+_s,true,true);
    }
  }}
}

inline const std::string& insh_style_print_colormaps_help() {
  static const std::string s_help("\
style_print_colormaps: style_print_colormaps\n\
  Print the known colormaps.\n\
");
  return s_help;
}

inline void insh_open(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_open :");
  args _args(a_args);
  std::string file;
  if(!_args.first_not_hyphen(file)) {
    a_gv.insh().warn(s_header+" no output file given.");
    return;
  }
  _args.remove(file);
  if(_args.is_arg("-doc_res")) {
    std::string path;
    if(!a_gv.find_doc_res_file(file,path)) {
      a_gv.insh().warn(s_header+" file "+inlib::sout(file)+" not found in doc and res dirs.");
      return;
    }
    file = path;
    _args.remove("-doc_res");
  } else if(_args.is_arg("-doc")) {
    std::string path;
    if(!a_gv.find_doc_file(file,path)) {
      a_gv.insh().warn(s_header+" file "+inlib::sout(file)+" not found in doc dir.");
      return;
    }
    file = path;
    _args.remove("-doc");
  } else if(_args.is_arg("-res")) {
    std::string path;
    if(!a_gv.find_res_file(file,path)) {
      a_gv.insh().warn(s_header+" file "+inlib::sout(file)+" not found in res dir.");
      return;
    }
    file = path;
    _args.remove("-res");
  }
  bool done;
  if(!a_gv.opener().open(file,file::s_format_guessed(),_args,done)) {
    a_gv.insh().warn(s_header+" opener.open() failed for "+inlib::sout(file)+".");
    return;
  }
  if(!done) {
    //gui_text(const std::vector<std::string>& a_data);
    a_gv.insh().warn(s_header+" app opener can't open "+inlib::sout(file)+".");
    return;
  }
}

inline const std::string& insh_open_help() {
  static const std::string s_help("\
open: open [-doc,-res,-doc_res] path\n\
  Attempt to open a file. The known file types depend of the \"openers\" declared to the app.\n\
  If no directory is given in path, the -doc_res option permits to search a file first\n\
  in the document directory declared to the app, and then in the app (internal) resource directory.\n\
  -res for the resource directory only, -doc for the document directory only.\n\
  See also:\n\
    app_dir -res\n\
    app_dir -doc.\n\
");
    return s_help;
}

inline void insh_openers(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  args _args(a_args);
  std::vector<std::string> vs;
  if(_args.is_arg("-exts")) {
    inlib_vforcit(std::string,a_gv.opener().exts(),it) {vs.push_back(*it);}
  } else {
    inlib_vforcit(opener::named_opener_t,a_gv.opener().openers(),it) {vs.push_back((*it).first);}
  }
  a_gv.insh().out_begin();
  a_gv.insh().out(vs,true);
}

inline const std::string& insh_openers_help() {
  static const std::string s_help("\
openers: openers [-exts]\n\
  List operners known by the application. -exts permits to list the known file extensions.\n\
");
    return s_help;
}

inline bool insh_camera_yaw(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if((a_args.size()!=1)&&(a_args.size()!=2)) {
    a_gv.insh().warn("inlib::sg::insh_camera_yaw : one or two argument expected");
    return true;
  }
  float angle;
  if((a_args.size()==1)) {
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_yaw",a_args[0],angle)) return true;
  } else { //two args.
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_yaw",a_args[1],angle)) return true;
    if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
      a_gv.insh().warn("inlib::sg::insh_camera_yaw : -deg or -degree exepected for first argument.");
      return false;
    }
    angle *= fdeg2rad();
  }
  if(!a_gv.scene_camera()) return false;
  a_gv.scene_camera()->rotate_around_up(angle);
  a_gv.set_params_camera();
//a_gv.scene_camera()->rotate_around_x(da);
//a_gv.scene_camera()->translate_along_side(dx);
//a_gv.scene_camera()->translate_along_up(dx);
//a_gv.scene_camera()->translate_along_dir(dx);
//a_gv.scene_camera()->rotate_around_y_at_focal(-da);
//a_gv.scene_camera()->rotate_around_x_at_focal(-da);
  return true;
}

inline bool insh_camera_pitch(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if((a_args.size()!=1)&&(a_args.size()!=2)) {
    a_gv.insh().warn("inlib::sg::insh_camera_pitch : one or two argument expected");
    return true;
  }
  float angle;
  if((a_args.size()==1)) {
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_pitch",a_args[0],angle)) return true;
  } else { //two args.
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_pitch",a_args[1],angle)) return true;
    if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
      a_gv.insh().warn("inlib::sg::insh_camera_pitch : -deg or -degree exepected for first argument.");
      return false;
    }
    angle *= fdeg2rad();
  }
  if(!a_gv.scene_camera()) return false;
  a_gv.scene_camera()->rotate_around_x(angle);
  a_gv.set_params_camera();
  return true;
}

inline bool insh_camera_roll(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if((a_args.size()!=1)&&(a_args.size()!=2)) {
    a_gv.insh().warn("inlib::sg::insh_camera_roll : one or two argument expected");
    return true;
  }
  float angle;
  if((a_args.size()==1)) {
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_roll",a_args[0],angle)) return true;
  } else { //two args.
    if(!a_gv.insh().get_arg_float("inlib::sg;:gui_viewer::_camera_roll",a_args[1],angle)) return true;
    if((a_args[0]!="-deg")&&(a_args[0]!="-degree")) {
      a_gv.insh().warn("inlib::sg::insh_camera_roll : -deg or -degree exepected for first argument.");
      return false;
    }
    angle *= fdeg2rad();
  }
  if(!a_gv.scene_camera()) return false;
  a_gv.scene_camera()->rotate_around_direction(-angle);
  a_gv.set_params_camera();
  return true;
}

inline bool insh_camera_rotate(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  base_camera* _cam = a_gv.scene_camera();
  if(!_cam) return false;
  inlib::args args(a_args);
  float angle;
  args.find("-angle",angle,0.0f);
  if(args.is_arg("-deg")||args.is_arg("-degree")) angle *= fdeg2rad();
  bool at_focal = args.is_arg("-at_focal");
  if(args.is_arg("-x")) {
    if(at_focal) {
      _cam->rotate_around_x_at_focal(angle);
    } else {
      _cam->rotate_around_x(angle);
    }
  } else if(args.is_arg("-y")) {
    if(at_focal) {
      _cam->rotate_around_y_at_focal(angle);
    } else {
      _cam->rotate_around_up(angle);
    }
  } else if(args.is_arg("-z")) {
    if(at_focal) {
      _cam->rotate_around_z_at_focal(angle);
    } else {
      _cam->rotate_around_z(angle);
    }
  } else {
    a_gv.insh().warn("inlib::sg::insh_camera_rotate : -x or -y or -z expected.");
    return false;
  }
  a_gv.set_scene_camera(_cam);
  return true;
}

inline const std::string& insh_camera_rotate_help() {
  static const std::string s_help("\
camera_rotate: camera_rotate [-x,-y,-z] [-at_focal] [-deg,-degree] [-angle=angle]\n\
  Rotate the camera around an axis of the given angle.\n\
  If -deg or -degree is specified, the angle is in degree (default is then radian).\n\
  If -at_focal is given, the center of rotation if the focal point, else\n\
  it is the current camera position.\n\
  -x or -y or -z specifies the axis of rotation (one must be specified).\n\
  The frame follows the usual OpenGL convention : x axis points to the right,\n\
  y axis points to the up direction and the z axis is pointing off the screen.\n\
  Example:\n\
    camera_rotate -z -deg -angle=-20  # to roll by -20 degrees.\n\
");
  return s_help;
}

inline void insh_count_points(gui_viewer& a_gv) {
  count_action ca(a_gv.out());
  a_gv.scene().bbox(ca);
  a_gv.insh().out_begin();
  std::string _s;
  num2s(ca.number_of_points(),_s);
  a_gv.insh().out(_s);
}

#define INLIB_INSH_CAMERA_SET(a__field)\
inline void insh_camera_set_##a__field(gui_viewer& a_gv,const std::vector<std::string>& a_args) {\
  static const std::string s_header("inlib::sg::insh_camera_set_"+std::string(#a__field)+" :");\
  if(a_args.size()!=1) {\
    a_gv.insh().warn(s_header+" one argument expected");\
    return;\
  }\
  float _value;\
  if(!a_gv.insh().get_arg_float(s_header,a_args[0],_value)) return;\
  base_camera* _cam = a_gv.scene_camera();\
  if(!_cam) return;\
  _cam->a__field = _value;\
  a_gv.set_scene_camera(_cam);\
}

INLIB_INSH_CAMERA_SET(znear)
INLIB_INSH_CAMERA_SET(zfar)
INLIB_INSH_CAMERA_SET(focal)
INLIB_INSH_CAMERA_SET(da)
INLIB_INSH_CAMERA_SET(dx)
INLIB_INSH_CAMERA_SET(ds)

#undef INLIB_INSH_CAMERA_SET

inline void insh_camera_set_orientation(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::insh_camera_set_orientation :");
    base_camera* _cam = a_gv.scene_camera();
    if(!_cam) return;
    if(a_args.size()!=4) {
      a_gv.insh().warn(s_header+" three argument expected");
      return;
    }
    float x;
    if(!a_gv.insh().get_arg_float(s_header,a_args[0],x)) return;
    float y;
    if(!a_gv.insh().get_arg_float(s_header,a_args[1],y)) return;
    float z;
    if(!a_gv.insh().get_arg_float(s_header,a_args[2],z)) return;
    float angle;
    if(!a_gv.insh().get_arg_float(s_header,a_args[3],angle)) return;
    _cam->orientation = rotf(vec3f(x,y,z),angle);
    a_gv.set_scene_camera(_cam);
}

inline const std::string& insh_camera_set_orientation_help() {
  static const std::string s_help("\
camera_set_orientation: camera_set_orientation x y z angle\n\
  Set camera.orientation = rotf(vec3f(x,y,z),angle).\n\
");
  return s_help;
}

inline void insh_camera_set_position(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::insh_camera_set_position :");
    if(a_args.size()!=3) {
      a_gv.insh().warn(s_header+" three argument expected");
      return;
    }
    float tx;
    if(!a_gv.insh().get_arg_float(s_header,a_args[0],tx)) return;
    float ty;
    if(!a_gv.insh().get_arg_float(s_header,a_args[1],ty)) return;
    float tz;
    if(!a_gv.insh().get_arg_float(s_header,a_args[2],tz)) return;
    base_camera* _cam = a_gv.scene_camera();
    if(!_cam) return;
    _cam->position = vec3f(tx,ty,tz);
    a_gv.set_scene_camera(_cam);
}

inline const std::string& insh_camera_set_position_help() {
  static const std::string s_help("\
camera_set_position: camera_set_position x y z\n\
  Set camera.position to be x,y,z.\n\
  Example:\n\
    camera_set_position 0 0 10\n\
");
  return s_help;
}

inline void insh_camera_translate_position(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::insh_camera_translate_position :");
    if(a_args.size()!=3) {
      a_gv.insh().warn(s_header+" three argument expected");
      return;
    }
    float tx;
    if(!a_gv.insh().get_arg_float(s_header,a_args[0],tx)) return;
    float ty;
    if(!a_gv.insh().get_arg_float(s_header,a_args[1],ty)) return;
    float tz;
    if(!a_gv.insh().get_arg_float(s_header,a_args[2],tz)) return;
    base_camera* _cam = a_gv.scene_camera();
    if(!_cam) return;
    _cam->position += vec3f(tx,ty,tz);
    a_gv.set_scene_camera(_cam);
}

inline const std::string& insh_camera_translate_position_help() {
  static const std::string s_help("\
camera_translate_position: camera_translate_position x y z\n\
  Translate the camera.position by x,y,z.\n\
  Example:\n\
    camera_translate_position 10 20 30\n\
");
  return s_help;
}

inline void insh_camera_zoom(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::insh_camera_zoom :");
    if(a_args.size()!=1) {
      a_gv.insh().warn(s_header+" one argument expected");
      return;
    }
    float factor;
    if(!a_gv.insh().get_arg_float(s_header,a_args[0],factor)) return;
    if(factor<=0) {
      a_gv.insh().warn(s_header+" first argument "+sout(a_args[0])+" must be >0.");
      return;
    }
    //  factor = 0.99f is a zoom in
    //  factor = 1.01f is a zoom out
    base_camera* _cam = a_gv.scene_camera();
    if(!_cam) return;
    _cam->zoom(factor);
    a_gv.set_scene_camera(_cam);
}

inline const std::string& insh_camera_zoom_help() {
  static const std::string s_help("\
camera_zoom: camera_zoom factor\n\
  Zoom in or out camera.\n\
  Example:\n\
    camera_zoom 0.99  # is a zoom in.\n\
    camera_zoom 1.01  # is a zoom out.\n\
");
  return s_help;
}

inline void insh_camera_start_anim(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if((a_args.size()!=1)&&(a_args.size()!=2)) {
    a_gv.insh().warn("inlib::sg::insh_camera_start_anim : one or two argument expected");
    return;
  }
  std::string smove = a_args[0];
  if(a_args.size()==2) smove = a_args[1];
  move_type _move;
  if(!smove_type(smove,_move)) {
    a_gv.insh().warn("inlib::sg::insh_camera_start_anim : "+sout(smove)+" is not a move_type.");
    return;
  }
  unsigned int cycle_secs = 10; //idem m_params.m_cycle_secs default.
  if(a_args.size()==2) {
    std::string opt,value;
    if(!cmd_arg(a_args[0],opt,value)) {
      a_gv.insh().warn("inlib::sg::insh_camera_start_anim : "+sout(a_args[0])+" is not -<string>=<string>.");
      return;
    }
    if(opt!="cycle_secs") {
      a_gv.insh().warn("inlib::sg::insh_camera_start_anim : "+sout(opt)+" is an unknow option.");
      return;
    }
    if(!a_gv.insh().get_arg_uint("inlib::sg::insh_camera_start_anim",value,cycle_secs)) return;
  }
  a_gv.start_cam_move(_move,cycle_secs);
}

inline const std::string& insh_camera_start_anim_help() {
    static const std::string s_help("\
camera_start_anim: camera_start_anim [-cycle_secs=secs] anim\n\
  Start a camera animation. The anim argument could be :\n\
    move_rotate_right\n\
    move_rotate_left\n\
    move_rotate_up\n\
    move_rotate_down\n\
    move_roll_plus\n\
    move_roll_minus\n\
    move_translate_right\n\
    move_translate_left\n\
    move_up\n\
    move_down\n\
    move_forward\n\
    move_backward\n\
    move_zoom_in\n\
    move_zoom_out\n\
    move_rotate_around_focal_right\n\
    move_rotate_around_focal_left\n\
    move_rotate_around_focal_up\n\
    move_rotate_around_focal_down\n\
    move_roll_around_focal_plus\n\
    move_roll_around_focal_minus\n\
    move_zoom_in_out\n\
    move_zoom_in_out_rot\n\
    move_curve\n\
  For move_zoom_in_out, move_zoom_in_out_rot and move_curve, the -cycle_secs option\n\
  permits to set the cycle time in seconds (it is 10 secs by default).\n\
  Use camera_stop_anim to stop the animation.\n\
");
  return s_help;
}

inline void insh_show_console(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  std::string sa;
  conc(a_args," ",sa);
  a_gv.show_console(sa);
}

inline void insh_set_console_layout(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  if(a_args.empty()) {
    a_gv.set_console_size();
    return;
  }
  args _args(a_args);
  bool changed = false;
 {float value;
  if(_args.find("-width",value)) {
    if(value!=a_gv.m_params.m_console_width) {
      a_gv.m_params.m_console_width = value;
      if(a_gv.m_params.m_console_width<=0) a_gv.m_params.m_console_width = 0.3F;
      changed = true;
    }
  }}
 {float value;
  if(_args.find("-height",value)) {
    if(value!=a_gv.m_params.m_console_height) {
      a_gv.m_params.m_console_height = value;
      if(a_gv.m_params.m_console_height<=0) a_gv.m_params.m_console_height = 0.05F;
      changed = true;
    }
  }}
 {float value;
  if(_args.find("-scale",value)) {
    if(value!=a_gv.m_params.m_console_scale) {
      a_gv.m_params.m_console_scale = value;
      if(a_gv.m_params.m_console_scale<=0) a_gv.m_params.m_console_scale = 1;
      changed = true;
    }
  }}
  if(changed) a_gv.set_console_layout();
}

inline const std::string& insh_set_console_layout_help() {
  static const std::string s_help("\
gui_set_console_layout: gui_set_console_layout [width] [height] [scale]\n\
  Set the console width and/or height. -scale can set an extra scaling factor.\n\
  Width and height are in normal window coordinates (in [0,1]).\n\
  Example:\n\
    gui_set_console_layout -width=0.5 -height=0.06 -scale=1.2\n\
    gui_set_console_layout -width=0.5  # half window width.\n\
    gui_set_console_layout -scale=2\n\
    gui_set_console_layout  # reset default layout (width=0.3, height=0.05, scale=1) \n\
");
  return s_help;
}

inline void insh_app_dir(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_app_dir :");
  if(a_args.empty()) {
    a_gv.insh().out_begin();
    a_gv.insh().out(a_gv.res_dir(),true);
    a_gv.insh().out(a_gv.doc_dir(),true);
    a_gv.insh().out(a_gv.out_dir(),true);
    a_gv.insh().out(a_gv.start_dir(),true);
    a_gv.insh().out(a_gv.tmp_dir(),true);
    return;
  }
  const std::string& arg0 = a_args[0];
  if(arg0=="-res") {
    a_gv.insh().out(a_gv.res_dir());
    return;
  }
  if(arg0=="-doc") {
    a_gv.insh().out(a_gv.doc_dir());
    return;
  }
  if(arg0=="-out") {
    a_gv.insh().out(a_gv.out_dir());
    return;
  }
  if(arg0=="-start") {
    a_gv.insh().out(a_gv.start_dir());
    return;
  }
  if(arg0=="-tmp") {
    a_gv.insh().out(a_gv.tmp_dir());
    return;
  }
  a_gv.insh().warn(s_header+" unknown option "+sout(arg0)+".");
}

inline const std::string& insh_app_dir_help() {
  static const std::string s_help("\
app_dir: app_dir [-res,-doc,-out,-tmp,-start]\n\
  Print the application [resource,document,output,startup,temporary] directory.\n\
  If no option given, print all of them in this order.\n\
  Example:\n\
    app_dir\n\
    app_dir -res.\n\
");
  return s_help;
}

inline void insh_app_color_value(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_app_color_value :");
  inlib::args _args(a_args);
  std::string scolor;
  if(!_args.first_not_hyphen(scolor)) {
    a_gv.insh().warn(s_header+" no color given.");
    return;
  }
  colorf _value;
  if(!find_color(a_gv.styles().cmaps(),scolor,_value)) {
    a_gv.insh().warn(s_header+" "+sout(scolor)+" is not a color.");
    return;
  }
  if(_args.is_arg("-r")) {
    std::string _s;
    num2s(_value.r(),_s);
    a_gv.insh().out(_s);
    return;
  }
  if(_args.is_arg("-g")) {
    std::string _s;
    num2s(_value.g(),_s);
    a_gv.insh().out(_s);
    return;
  }
  if(_args.is_arg("-b")) {
    std::string _s;
    num2s(_value.b(),_s);
    a_gv.insh().out(_s);
    return;
  }
  if(_args.is_arg("-a")) {
    std::string _s;
    num2s(_value.a(),_s);
    a_gv.insh().out(_s);
    return;
  }
  if(_args.is_arg("-rgb")) {
    std::string _s;
    numas(_value.r(),_s);
    _s += " ";
    numas(_value.g(),_s);
    _s += " ";
    numas(_value.b(),_s);
    a_gv.insh().out(_s);
    return;
  }
  std::string _s;
  numas(_value.r(),_s);
  _s += " ";
  numas(_value.g(),_s);
  _s += " ";
  numas(_value.b(),_s);
  _s += " ";
  numas(_value.a(),_s);
  a_gv.insh().out(_s);
}

inline const std::string& insh_app_color_value_help() {
  static const std::string s_help("\
app_color_value: app_color_value [-r,-g,-b,-a,-rgba] colorname\n\
  Print the rgba of a color given its name.\n\
  -r to print only the red value (in [0,1]).\n\
  -g to print only the green value (in [0,1]).\n\
  -b to print only the blue value (in [0,1]).\n\
  -a to print only the alpha value (in [0,1]).\n\
  -rgb to print only red, green, blue.\n\
  Example:\n\
    app_color_value red\n\
    app_color_value -r red\n\
    app_color_value -rgb red\n\
");
  return s_help;
}

inline bool insh_scene_write_to_paper(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
    static const std::string s_header("inlib::sg::insh_scene_write_to_paper :");
    inlib::args _args(a_args);
    std::string path;
    if(_args.is_arg("-out_dir")) {
      if(a_gv.out_dir().empty()) {
        a_gv.insh().warn(s_header+" out_dir() is empty.");
        return false;
      }
      if(!check_dir(a_gv.out(),a_gv.out_dir())) {
        a_gv.insh().warn(s_header+" can't get out_dir.");
        return false;
      }
      path = a_gv.out_dir()+sep();
    }
    std::string file;
    if(!_args.first_not_hyphen(file)) {
      a_gv.insh().warn(s_header+" no output file given.");
      return false;
    }
    path += file;
    std::string format;
    _args.find("-format",format,"guessed");
    if(format=="guessed") {
      if(!inlib::file::extension_paper_format(path,format)) {
        a_gv.insh().warn(s_header+" can't guess format from extension of "+inlib::sout(path)+".");
        return false;
      }
    } else {
      if(!inlib::file::is_paper_format(format)) {
        a_gv.insh().warn(s_header+" unknown format "+inlib::sout(format)+".");
        return false;
      }
    }
    unsigned int scale;
    _args.find<unsigned int>("-scale",scale,1);
    if(!a_gv.write_scene_to_paper(path,format,scale)) {
      a_gv.insh().warn(s_header+" write_scene_to_paper() failed for format "+inlib::sout(format)+".");
      return false;
    }
    if(_args.is_arg("-show_console")) a_gv.show_console(path+" produced.");
    return true;
}

inline const std::string& insh_scene_write_to_paper_help() {
  static const std::string s_help("\
scene_write_to_paper: scene_write_to_paper [-out_dir] [-scale] [-format] [-show_console] file\n\
  Produce an output file from the current scene.\n\
  -out_dir permits to write the file in the output directory of the application.\n\
  -scale permits to scale the viewport; it allows to have a better rendering for freetype fonts.\n\
  -show_console prints the name of the output file in the console.\n\
  -format permits to choose the output format and the tool to produce the file.\n\
  If 'guessed', which is the default, the format is choosen/deduced from the file extension.\n\
  For example for out.png, the format will be inzb_png.\n\
  The known formats are:\n\
    inzb_[ps,png,jpeg] : pixmap of the scene is put in a PostScript, png or jpeg file\n\
  by using the inlib::sg::zb_action.\n\
    gl2ps_[eps,ps,pdf,svg,tex,pdg] : primitives of the scene (vector graphices) is put in an\n\
  encapsulated PostScript, PostScript, PDF, SVG, LaTeX or PDG file by using gl2ps.\n\
  If 'guessed' is used as format, then according to the file extension, the tool used is:\n\
    .ps, .eps: inzb_ps\n\
    .png : inzb_png\n\
    .jpg, .jpeg: inzb_jpeg\n\
    .pdf, .svg, .pgf, .tex: gl2ps_[pdf,svg,pgf,tex]\n\
  Example:\n\
    scene_write_to_paper out.jpeg  # produce a out.jpeg file in current directory by using inzb_jpeg.\n\
    scene_write_to_paper -out_dir -format=inzb_png -scale=2 out.png\n\
    scene_write_to_paper -format=gl2ps_pdf out.pdf\n\
    scene_write_to_paper -format=guessed -show_console out.pgf\n\
  See also:\n\
    app_out_dir\n\
");
  return s_help;
}

inline const std::string& insh_scene_write_to_bsg_help() {
    static const std::string s_help("\
scene_write_to_bsg: scene_write_to_bsg [-out_dir] file\n\
  Write the scene scene graph to a bsg (binary file format) file.\n\
  If no directory is given in file, the -out_dir option permits to prepend the\n\
  application output directory to file.\n\
  See also: app_dir -out_dir\n\
  Example:\n\
    scene_write_to_bsg -out_dir my_scene.bsg\n\
");
    return s_help;
}

/*
  static void setup_anims(std::ostream& a_out,node& a_from,float a_time_min,float a_time_max,float a_delay,bool a_end_begin) {
    search_action sa(a_out);
    typedef search_action::path_t path_t;
    const std::vector<path_t>& paths = find_paths(sa,a_from,slice_anim::s_class());
    inlib_vforcit(path_t,paths,it) {
      const path_t& p = *it;
      node* _node = p.size()?p[p.size()-1]:0;
      if(!_node) continue;
      slice_anim* _anim = safe_cast<node,slice_anim>(*_node);
      if(!_anim) continue;
      _anim->time_min = a_time_min;
      _anim->time_max = a_time_max;
      _anim->delay = a_delay;
      _anim->end_begin = a_end_begin;
      _anim->set_start(atime::now());
      //::printf("debug : start anim %lu\n",_anim);
    }
  }
*/

#define INLIB_GUI_VIEWER__GET_ARG_FLOAT(a__variable)\
   {std::string svalue;\
    if(_args.find(std::string("-")+#a__variable,svalue)) {\
      float _value;\
      if(!inlib::to<float>(svalue,_value)) {\
        a_gv.insh().warn(s_header+" : "+svalue+" is not a float.");\
        return;\
      }\
      a__variable  = _value;\
    }}

#define INLIB_GUI_VIEWER__GET_ARG_BOOL(a__variable)\
   {std::string svalue;\
    if(_args.find(std::string("-")+#a__variable,svalue)) {\
      bool _value;\
      if(!inlib::to(svalue,_value)) {\
        a_gv.insh().warn(s_header+" : "+svalue+" is not a bool.");\
        return;\
      }\
      a__variable  = _value;\
    }}

inline void insh_scene_start_anim(gui_viewer& a_gv,const std::vector<std::string>& a_args) {
  static const std::string s_header("inlib::sg::insh_scene_start_anim :");
  args _args(a_args);
  float time_min = FLT_MAX;
  INLIB_GUI_VIEWER__GET_ARG_FLOAT(time_min)
  float time_max = FLT_MIN;
  INLIB_GUI_VIEWER__GET_ARG_FLOAT(time_max)
  float delay = 0;
  INLIB_GUI_VIEWER__GET_ARG_FLOAT(delay)
  bool end_begin = false;
  INLIB_GUI_VIEWER__GET_ARG_BOOL(end_begin)
  a_gv.setup_anims(a_gv.out(),a_gv.scene(),time_min,time_max,delay,end_begin);
  a_gv.enable_anim();
}

#undef INLIB_GUI_VIEWER__GET_ARG_DOUBLE
#undef INLIB_GUI_VIEWER__GET_ARG_BOOL

inline const std::string& insh_scene_start_anim_help() {
  static const std::string s_help("\
scene_start_anim: scene_start_anim [-tim_min,-time_max,-delay,-end_begin]\n\
  Start scene animation. It operates on all nodes in the scene inheriting sg::slice_anim\n\
  as xyzt_anim, cone_anim, show_time_anim.\n\
  -time_min=real event time start (in app specific unit).\n\
  -time_max=real event time end (in app specific unit).\n\
  -delay=real user elapsed time of the anim in secs.\n\
  -end_begin=bool if true, start again at end (default is false).\n\
  Example:\n\
    scene_start_anim -tim_min=0 -time_max=20 -delay=10\n\
");
    return s_help;
}

}}

#define INLIB_GUI_VIEWER_INSH_CLASSES(a__holder)\
  INLIB_INSH_CLASS_CMD(a__holder,camera_rotate,insh_camera_rotate(m_holder,a_args),inlib::sg::insh_camera_rotate_help())\
  INLIB_INSH_CLASS_CMD(a__holder,camera_start_anim,insh_camera_start_anim(m_holder,a_args),inlib::sg::insh_camera_start_anim_help())\
  INLIB_INSH_CLASS_CMD(a__holder,gui_set_console_layout,insh_set_console_layout(m_holder,a_args),inlib::sg::insh_set_console_layout_help())\
  INLIB_INSH_CLASS_CMD(a__holder,camera_yaw,insh_camera_yaw(m_holder,a_args),"camera_yaw: camera_yaw [-deg,-degree] value\n  Rotate the camera around the up axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_pitch,insh_camera_pitch(m_holder,a_args),"camera_pitch: camera_pitch [-deg,-degree] value\n  Rotate the camera around the left-right/x axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_roll,insh_camera_roll(m_holder,a_args),"camera_roll: camera_roll [-deg,-degree] value\n  Rotate the camera around the direction of view axis.\n  If specifying -deg or -degree, the value is taken in degrees.\n")\
\
  INLIB_INSH_CLASS_CMD(a__holder,camera_translate_position,insh_camera_translate_position(m_holder,a_args),inlib::sg::insh_camera_translate_position_help())\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_position,insh_camera_set_position(m_holder,a_args),inlib::sg::insh_camera_set_position_help())\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_orientation,insh_camera_set_orientation(m_holder,a_args),inlib::sg::insh_camera_set_orientation_help())\
  INLIB_INSH_CLASS_CMD(a__holder,camera_zoom,insh_camera_zoom(m_holder,a_args),inlib::sg::insh_camera_zoom_help())\
\
  INLIB_INSH_CLASS_CMD(a__holder,scene_write_to_paper,insh_scene_write_to_paper(m_holder,a_args),inlib::sg::insh_scene_write_to_paper_help())\
  INLIB_INSH_CLASS_CMD(a__holder,scene_write_to_bsg,insh_node_to_bsg(m_holder,a_args,m_holder.scene()),inlib::sg::insh_scene_write_to_bsg_help())\
  INLIB_INSH_CLASS_CMD(a__holder,scene_count_points,insh_count_points(m_holder),"scene_count_points: scene_count_points\n Count number of points in the scene.\n")\
/*INLIB_INSH_CLASS_CMD(a__holder,scene_clear,m_holder.clear_scene(),insh::no_help())*/\
\
  INLIB_INSH_CLASS_CMD(a__holder,event_stop_anim,m_holder.stop_event_anim(),"event_stop_anim: event_stop_anim\n  Stop the looping on events animation.\n")\
\
  INLIB_INSH_CLASS_CMD(a__holder,scene_light_on,m_holder.set_scene_light_on(true),"scene_light_on: scene_light_on\n  Switch on the overall light.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,scene_light_off,m_holder.set_scene_light_on(false),"scene_light_off: scene_light_off\n  Switch off the overall light.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,scene_blend_on,m_holder.set_scene_blend_on(true),"scene_blend_on: scene_blend_on\n  Switch on the overall blending (and then transparency).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,scene_blend_off,m_holder.set_scene_blend_on(false),"scene_blend_off: scene_blend_off\n  Switch off the overall blending (and then transparency).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,scene_smooth_on,m_holder.set_scene_smooth_on(true),"scene_smooth_on: scene_smooth_on\n  Switch the overall shade model to smooth.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,scene_smooth_off,m_holder.set_scene_smooth_on(false),"scene_smooth_off: scene_smooth_off\n  Switch the overall shade model to flat.\n")\
\
  INLIB_INSH_CLASS_CMD(a__holder,scene_start_anim,insh_scene_start_anim(m_holder,a_args),inlib::sg::insh_scene_start_anim_help())\
  INLIB_INSH_CLASS_CMD(a__holder,scene_set_clear_color,insh_scene_set_clear_color(m_holder,a_args),inlib::sg::insh_scene_set_clear_color_help())\
  INLIB_INSH_CLASS_CMD(a__holder,scene_bounding_box,insh_scene_bounding_box(m_holder,a_args),inlib::sg::insh_scene_bounding_box_help())\
  INLIB_INSH_CLASS_CMD(a__holder,scene_remove_nodes,insh_scene_remove_nodes(m_holder,a_args),inlib::sg::insh_scene_remove_nodes_help())\
\
  INLIB_INSH_CLASS_CMD(a__holder,window_render,m_holder.win_render(),"window_render: window_render\n  Enforce an immediate rendering of the window.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,window_to_png,insh_window_to_png(m_holder,a_args),inlib::sg::insh_window_to_png_help())\
  INLIB_INSH_CLASS_CMD(a__holder,window_to_jpeg,insh_window_to_jpeg(m_holder,a_args),inlib::sg::insh_window_to_jpeg_help())\
\
  INLIB_INSH_CLASS_CMD(a__holder,gui_hide_console,m_holder.hide_console(),"gui_hide_console: gui_hide_console\n  Hide the upper left console text.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_hide_main_menu,m_holder.hide_main_menu(),"gui_hide_main_menu: gui_hide_main_menu\n  Hide the main menu and show the scene.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_show_main_menu,m_holder.show_main_menu(),"gui_show_main_menu: gui_show_main_menu\n  Show the main menu.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_hide_camera_menu,m_holder.hide_camera_menu(),"gui_hide_camera_menu: gui_hide_camera_menu\n  Hide the camera menu items.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_show_camera_menu,m_holder.show_camera_menu(),"gui_show_camera_menu: gui_show_camera_menu\n  Show the camera menu items.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_push_home,m_holder.push_home(),"gui_push_home: gui_push_home\n  Show the top list items in the main menu.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_push_back_item,m_holder.push_back_item(),"gui_push_back_item: gui_push_back_item\n  If being in a submenu of the main menu, return to the parent menu.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_hide_meta_zone,m_holder.hide_meta_zone(),"gui_hide_meta_zone: gui_hide_meta_zone\n  Hide the light blue area at the bottom of the window that permits to switch between scene mode and main menu mode.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_set_viewing_mode,m_holder.set_param_viewing(true),"gui_set_viewing_mode: gui_set_viewing_mode\n  When in scene mode, pass the cursor/touching in viewing mode.\n  It permits to move the camera with the mouse/touches.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_set_picking_mode,m_holder.set_param_viewing(false),"gui_set_picking_mode: gui_set_picking_mode\n  When in scene mode, pass the cursor/touching in picking mode.\n  It permits to pick an object and have a contextual popup on it.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_set_to_exit,m_holder.set_to_exit(),"gui_set_to_exit: gui_set_to_exit\n  Raise the application exit flag.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_text,m_holder.gui_text(a_args),"gui_text: gui_text [strings]\n  Show strings in a text widget.\n  gui_text line_1 line_2 line_3\n  gui_show_main_menu\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_scroll_text,m_holder.gui_scroll_text(a_args),"gui_scroll_text: gui_scroll_text [strings]\n  Show strings in a scrolling text widget.\n  gui_scroll_text line_1 line_2 line_3 line_4 line_5 line_6\n  gui_show_main_menu\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_show_console,insh_show_console(m_holder,a_args),"gui_show_console: gui_show_console\n  Show the upper left console text.\n")\
\
  INLIB_INSH_CLASS_CMD(a__holder,gui_enable_anim,m_holder.enable_anim(),"gui_enable_anim: gui_enable_anim\n  Enable animations.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_disable_anim,m_holder.disable_anim(),"gui_disable_anim: gui_disable_anim\n  Disable animations.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,gui_exec_main_menu_item,insh_exec_main_menu_item(m_holder,a_args),inlib::sg::insh_exec_main_menu_item_help())\
  INLIB_INSH_CLASS_CMD(a__holder,gui_push_list,gui_push_list_insh(m_holder,a_args),"gui_push_list: gui_push_list [label script]\n  Show a list menu.\n  A list of pairs (label,script) must be provided.\n  gui_push_list 'item 1' 'echo item 1' 'item 2' 'echo item 2'\n  gui_show_main_menu\n")\
\
  INLIB_INSH_CLASS_CMD(a__holder,sys_home_dir,{std::string s;inlib::dir::home(s);m_holder.insh().out(s);},inlib::sys_home_dir_help())\
  INLIB_INSH_CLASS_CMD(a__holder,sys_file_sep,m_holder.insh().out(inlib::sep()),inlib::sys_file_sep_help())\
  INLIB_INSH_CLASS_CMD(a__holder,sys_path_sep,m_holder.insh().out(inlib::psep()),inlib::sys_path_sep_help())\
  INLIB_INSH_CLASS_CMD(a__holder,ls,inlib::insh_ls(m_holder.insh(),a_args),inlib::insh_ls_help())\
  INLIB_INSH_CLASS_CMD(a__holder,tput,inlib::insh_tput(m_holder.m_insh,a_args),inlib::insh_tput_help())\
  INLIB_INSH_CLASS_CMD(a__holder,style_print_colormaps,insh_style_print_colormaps(m_holder,a_args),inlib::sg::insh_style_print_colormaps_help())\
\
  INLIB_INSH_CLASS_CMD(a__holder,app_open,insh_open(m_holder,a_args),inlib::sg::insh_open_help())\
  INLIB_INSH_CLASS_CMD(a__holder,app_openers,insh_openers(m_holder,a_args),inlib::sg::insh_openers_help())\
  INLIB_INSH_CLASS_CMD(a__holder,app_dir,insh_app_dir(m_holder,a_args),inlib::sg::insh_app_dir_help())\
  INLIB_INSH_CLASS_CMD(a__holder,app_color_value,insh_app_color_value(m_holder,a_args),inlib::sg::insh_app_color_value_help())\
\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_znear,insh_camera_set_znear(m_holder,a_args),"camera_set_znear: camera_set_znear value\n  Set the camera znear (default 1).\n  znear is the distance toward the forward cut plan.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_zfar,insh_camera_set_zfar(m_holder,a_args),"camera_set_zfar: camera_set_zfar value\n  Set the camera zfar (default 10).\n  zfar is the distance toward the backward cut plan.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_focal,insh_camera_set_focal(m_holder,a_args),"camera_set_focal: camera_set_focal value\n  Set the camera focal length (default 1).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_da,insh_camera_set_da(m_holder,a_args),"camera_set_da: camera_set_da value\n  Set the rotation step factor in radians (default 0.017).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_dx,insh_camera_set_dx(m_holder,a_args),"camera_set_dx: camera_set_dx value\n  Set the translation step factor (default 0.01).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_set_ds,insh_camera_set_ds(m_holder,a_args),"camera_set_ds: camera_set_ds value\n  Set the zoom step factor (default 0.99).\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_view_all,m_holder.adapt_camera_to_scene(),"camera_view_all: camera_view_all\n  Arrange the camera so that all the scene elements are viewed.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_reset,m_holder.reset_camera(),"camera_reset: camera_reset\n  Reset camera parameters.\n  It is usefull if being lost in space.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_swap_kind,m_holder.swap_camera_kind(),"camera_swap_kind: camera_swap_kind\n  Swap camera between ortho and perspective.\n")\
  INLIB_INSH_CLASS_CMD(a__holder,camera_stop_anim,m_holder.stop_cam_anim(),"camera_stop_anim: camera_stop_anim,\n  If any on, stop a camera animation.\n")

#define INLIB_GUI_VIEWER_INSH_ADDS(a__insh,a__holder)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_view_all)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_reset)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_swap_kind)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_stop_anim)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_translate_position)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_position)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_orientation)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_zoom)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_znear)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_zfar)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_focal)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_da)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_dx)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_set_ds)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_start_anim)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_rotate)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_yaw)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_pitch)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,camera_roll)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,event_stop_anim)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,window_render)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,window_to_png)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,window_to_jpeg)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_light_on)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_light_off)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_blend_on)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_blend_off)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_smooth_on)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_smooth_off)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_write_to_paper)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_write_to_bsg)\
  /*INLIB_INSH_ADD_CMD(a__insh,a__holder,clear_scene)*/\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_count_points)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_set_clear_color)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_bounding_box)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_remove_nodes)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,scene_start_anim)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,style_print_colormaps)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_set_console_layout)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_hide_console)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_hide_main_menu)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_show_main_menu)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_hide_camera_menu)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_show_camera_menu)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_push_home)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_push_back_item)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_hide_meta_zone)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_text)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_scroll_text)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_set_viewing_mode)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_set_picking_mode)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_set_to_exit)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_show_console)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_exec_main_menu_item)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_enable_anim)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_disable_anim)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,gui_push_list)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,app_open)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,app_openers)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,app_dir)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,app_color_value)\
\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,sys_home_dir)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,sys_file_sep)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,sys_path_sep)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,ls)\
    INLIB_INSH_ADD_CMD(a__insh,a__holder,tput)

#undef INLIB_GUI_VIEWER_ADD_BOOL_VOID_CMD
#undef INLIB_GUI_VIEWER_ADD_VOID_VOID_CMD

//inlib_build_use kernel

#endif
