// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_inlib_insh_anim
#define inlib_inlib_insh_anim

#include "base_anim"
#include "group"

#include "mf"
#include "../insh"
#include "../num2s"
#include "../pointer"

namespace inlib {
namespace sg {

class insh_anim : public base_anim, public group {
  INLIB_NODE_NO_CAST(insh_anim,inlib::sg::insh_anim,group)
  typedef base_anim parent_anim;
//public:
//  static bool is_a(const std::string& a_class) {
//    if(rcmp(a_class,s_class())) return true;
//    if(rcmp(a_class,parent_anim::s_class())) return true;
//    return parent::is_a(a_class);
//  }
public:
  INLIB_CLASS_STRING(insh_anim_time_begin)
  INLIB_CLASS_STRING(insh_anim_time_end)
  INLIB_CLASS_STRING(insh_anim_object)
  INLIB_CLASS_STRING(insh_anim_class)
public:
  virtual void* cast(const std::string& a_class) const {
   {if(void* p = cmp_cast<insh_anim>(this,a_class)) return p;}
   {if(void* p = parent_anim::cast(a_class)) return p;}
    return parent::cast(a_class);
  }
public:
  virtual void begin_anim() {clear();}
  virtual bool end_anim() {
    if(end_begin.value()) {
      set_start(atime::now());
      return false;
    }
    return true;
  }
  virtual bool action(std::ostream&,const atime& a_now) {
    if(!is_valid()) {stop();return true;}

    double tp = atime::diff(m_prev,m_start).value();
    double t = atime::diff(a_now,m_start).value();

    double time_delta = time_max.value()-time_min.value();
    
    double time_beg = (tp/delay.value())*time_delta+time_min.value();
    double time_end = (t/delay.value())*time_delta+time_min.value();
    if(time_end<=time_beg) return true;

    std::string stime_beg;
    num2s(time_beg,stime_beg);
    std::string stime_end;
    num2s(time_end,stime_end);

    std::vector<std::string> lines;
    if(set_v.value()) lines.push_back("set -v");
    if(set_x.value()) lines.push_back("set -x");
    lines.push_back(s_insh_anim_time_begin()+"='"+stime_beg+"'");
    lines.push_back(s_insh_anim_time_end()+"='"+stime_end+"'");
  //lines.push_back("export "+s_insh_anim_time_begin());
  //lines.push_back("export "+s_insh_anim_time_end());

   {std::string sp;
    if(!inlib::p2s(this,sp)) {}
    lines.push_back(s_insh_anim_object()+"="+sp);}
    lines.push_back(s_insh_anim_class()+"="+s_cls());
  //lines.push_back("export "+s_insh_anim_object());
  //lines.push_back("export "+s_insh_anim_class());

    append(lines,script.values());

    if(show_console.value()) {
      std::string stmp;
      stmp += "time min ";
      if(!numas<double>(time_min.value(),stmp)) {}
      stmp += ", max ";
      if(!numas<double>(time_max.value(),stmp)) {}
      stmp += ", ";
      if(!numas<double>(time_beg,stmp)) {}
      stmp += "/";
      if(!numas<double>(time_end,stmp)) {}
      stmp += " (";
      if(!numas<double>(tp,stmp)) {}
      stmp += "/";
      if(!numas<double>(t,stmp)) {}
      stmp += ")";
      lines.push_back("gui_show_console "+stmp);
    }

    m_insh._exec_lines(lines);

    m_insh.remove_variable(s_insh_anim_time_begin());
    m_insh.remove_variable(s_insh_anim_time_end());
    m_insh.remove_variable(s_insh_anim_object());
    m_insh.remove_variable(s_insh_anim_class());

    return true;
  }
public:
  virtual void event(event_action& a_action) {
    parent::event(a_action);
    do_event(a_action);
  }
public:
  sf<double> time_min; //nsec
  sf<double> time_max; //nsec
  sf<bool> end_begin;
  mf_string script;
  sf<bool> show_console;
  sf<bool> set_v;
  sf<bool> set_x;
public:
  virtual const desc_fields& node_desc_fields() const {
    INLIB_FIELD_DESC_NODE_CLASS(insh_anim)
    static const desc_fields s_v(parent::node_desc_fields(),8, //WARNING : take care of count.
      INLIB_ARG_FIELD_DESC(delay),
      INLIB_ARG_FIELD_DESC(time_min),
      INLIB_ARG_FIELD_DESC(time_max),
      INLIB_ARG_FIELD_DESC(end_begin),
      INLIB_ARG_FIELD_DESC(script),
      INLIB_ARG_FIELD_DESC(show_console),
      INLIB_ARG_FIELD_DESC(set_v),
      INLIB_ARG_FIELD_DESC(set_x)
    );
    return s_v;
  }
protected:
  void add_fields(){
    add_field(&delay);
    add_field(&time_min);
    add_field(&time_max);
    add_field(&end_begin);
    add_field(&script);
    add_field(&show_console);
    add_field(&set_v);
    add_field(&set_x);
  }
public:
  insh_anim(const atime& a_start,insh& a_insh)
  :parent_anim(a_start)
  ,parent()
  ,m_insh(a_insh)

  ,time_min(0)
  ,time_max(20) //nsec
  ,end_begin(false)
  ,script()
  ,show_console(false)
  ,set_v(false)
  ,set_x(false)
  {
    add_fields();    
  }
  virtual ~insh_anim() {}
protected:
  insh_anim(const insh_anim& a_from)
  :parent_anim(a_from)
  ,parent(a_from)
  ,m_insh(a_from.m_insh)

  ,time_min(a_from.time_min)
  ,time_max(a_from.time_max)
  ,end_begin(a_from.end_begin)
  ,script(a_from.script)
  ,show_console(a_from.show_console)
  ,set_v(a_from.set_v)
  ,set_x(a_from.set_x)
  {
    add_fields();
  }
  insh_anim& operator=(const insh_anim& a_from){
    parent_anim::operator=(a_from);
    parent::operator=(a_from);
    time_min = a_from.time_min;
    time_max = a_from.time_max;
    end_begin = a_from.end_begin;
    script = a_from.script;
    show_console = a_from.show_console;
    set_v = a_from.set_v;
    set_x = a_from.set_x;
    return *this;
  }
public: 
  bool is_valid() const {
    if(delay.value()<=0) return false;
    if(time_max.value()<=time_min.value()) return false;
    return true;
  }
protected:
  insh& m_insh;
};

}}

#include "search"

namespace inlib {
namespace sg {

template <class NODE>
inline bool insh_anim_add_node(insh& a_insh,group& a_parent,NODE*& a_node) {  //we take ownership of a_node.
  const std::string& s_insh_anim_object = insh_anim::s_insh_anim_object();
  const std::string& s_insh_anim_class = insh_anim::s_insh_anim_class();
  std::string sinsh_anim_object;
  std::string sinsh_anim_class;
  const insh::state& _state = a_insh.get_state();
  if(_state.find_variable(s_insh_anim_object,sinsh_anim_object) &&
     _state.find_variable(s_insh_anim_class,sinsh_anim_class) ){
    void* p;
    if(!to_pointer(sinsh_anim_object,p)) {
      a_insh.warn("inlib::sg::insh_anim_add_node : can't convert "+sout(sinsh_anim_object)+" to a pointer.");
      delete a_node;
      a_node = 0;
      return false;
    }
    if(sinsh_anim_class!=insh_anim::s_class()) {
      a_insh.warn("inlib::sg::insh_anim_add_node : class "+sout(sinsh_anim_class)+" is not an "+insh_anim::s_class()+".");
      delete a_node;
      a_node = 0;
      return false;
    }
    insh_anim* _anim = (insh_anim*)p;
    
    if(true) {  // sanity check :
      search_action action(a_insh.out());
      const path_t& _path = find_path(action,a_parent,*_anim,false);
      if(_path.empty()) {
        a_insh.warn("inlib::sg::insh_anim_add_node : node "+sout(sinsh_anim_object)+" not found in dynamic scene.");
        delete a_node;
        a_node = 0;
        return false;
      }
    }

    _anim->add(a_node);
  } else {
    a_parent.add(a_node);
  }
  return true;
}

}}

#endif
