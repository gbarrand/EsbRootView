<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;h2&gt;insh&lt;/h2&gt;</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.18 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><h2>insh</h2>
</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The EsbRootView/2.x is equipped with the core of a Bourne like shell called "insh" for INlib SHell. It had been introduced to have a way to customize things by using a scripting syntax known by any UNIX pedestrian and easily implementable by a "doer" without having to embarque a million of lines of code to do that. insh has the basic mechanisms found on any bash shell: variables, env variables, dollar replacement of a variable, execute other scripts, source other scripts and, obviously, execute commands with options. For example in the neard_event.insh, you can see: </p><pre class="fragment">    # this is a comment.
    event_index=`event_index`
    gui_show_console ${event_index}
    scene_clear_dynamic
    #pickable='-pickable=true'
    pickable=
    event_vis MCTrack -color=red ${pickable}
    event_vis WCDetectorPoint -color=green ${pickable}
    event_plot WCDetectorPoint -modeling=neard  # example of a comment at end of line.
    return
    #...   
</pre><p>As for a Bourne shell, at startup of the program, the internal insh will source, if found and in this order, the files: </p><pre class="fragment">    ~/.insh
    ~/Documents/EsbRootView/.insh
    ~/Documents/EsbRootView/startup.insh
</pre><p> For example, in a .insh, you can have: </p><pre class="fragment">    echo 'hello my .insh'
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->

</body>
</html>
